////////////////////////////////////////////////
        0.WHAT IS SASS?

    Sass is a css preprocessor. That means you
write out Sass enhanced css in a .scss file and 
then compile it into a .css file.
    This allows you to take advantage of sass
things like variables, mixins, and functions, 
nut still output a regular .css file any browser
could read. 





////////////////////////////////////////////////
        1. INSTALL ON LINUX AND MAC

    In both cases, you need to install Ruby 
first, since Sass is a Ruby gem.

LINUX
    In the command line:
  sudo gem install sass --no-user-install

MAC
    It's just:
  gem install sass 
    If that gives you trouble use sudo

To double check Sass is installed, do:
  sass -v
to check the version and see that it's there





////////////////////////////////////////////////
        2. USE SASS

    Super simple, to convert a Sass file (.scss)
into a .css file, go into command line in the 
folder with the .scss file and:
  sass input-file.scss output-file.css
71G
WATCH COMMAND 
    Typing out the Sass command each time is 
tedious. the --watch command has Sass watch a
file or folder for changes to the scss files, and
then auto updates the css file of the same name.
    So, assuming you set up your project right,
with a /scss root folder for all .scss, and a 
/css folder for all css, you would use the 
watch command on a single file like this:

  sass --watch sccs/style.scss:css/style.css

To watch all scss files, use:
  
  sass --watch scss:css 

    Basically, the colon separates the watch
from the set. you can just use a single
  
  sass --watch .

if your sccs and css are in the same folder, but
this is poor organization. The folders can be 
anywhere, just give absolute path names.





////////////////////////////////////////////////
                3. VARIABLES
    Sass allows you to use variables like real
code. In the .scss file:

_____________________________________.scss_____
$font-stack:  Helvetica, sans-serif;
$primary-color: #333;

body {
  font-family: $font-stack;
  color: $primary-color;
}
________________________________________________

which will compile to:

_____________________________________.css_______
body {
  font-family: Helvetica, sans-serif;
  color: #333;
}
_________________________________________________

the formula is $name: value;

Use this to save so much time and make DRY (Don't
Repeat Yourself) code.

VARIABLE TYPES
  numbers: 10 10.1, even 10px is treated as a
          number (em and rem too)
  strings: "anything in quotes"
  booleans: true or false
  null: which is considered empty
  lists: this is a list; so, is, this; (so is me)
         (same, here). Lists can be separated by
         commas or just spaces, and can be inside
         () or not.
  maps: (key: value, key2: value2), so basically
        a dictionary
  NOTE: lists and maps can be nested. Also if the
        css variable needs commas (like a font
        stack), use them in the list. If it 
        doesn't (like border values) don't use
        them.





/////////////////////////////////////////////////
                  4. NESTING

    css is hard to read because it doesn't match
the DOM heirarchy visually. Sass puts nesting
into css:

------------------------------------- .scss ---  
nav {
  li {
    font-family: serif;
    text-size: 12px;
    a {
      display: block;
      padding: 0;
    }
  }
}
-----------------------------------------------
Easy to see the relationship, but compiles
perfectly to:
------------------------------------- .css ---  
nav li {
    font-family: serif;
    text-size: 12px;
}
nav li a {
 display: block;
 padding: 0;
}
}

/*Assume I remembered to put in a ul*/
-----------------------------------------------






///////////////////////////////////////////////
            5.MIXINS

    A mixin is a repeated code block that should
accept a variable. That way, you write the main 
block once, then use the argument to change it 
each time (like when applying lots of gradients)
    To use ,ixins, just start with @mixin

-------------------------------------- .scss - 
@mixin border-gradient($col, $col2) {
 background: -webkit-linear-gradient($cl, $cl2)
 background: -o-linear-gradient($cl, $cl2)
 background: -moz-linear-gradient($cl, $cl2)
 background: -linear-gradient($cl, $cl2)
}  
.box {
 @include border-gradient(red, pink);
}
---------------------------------------------
So you create a mixin, and then you insert it
with @include(arguments). and it compiles
to:
-------------------------------------- .css -
.box { 
 background: -webkit-linear-gradient(red, yello)
 background: -o-linear-gradient(red, yello)
 background: -moz-linear-gradient(red, yellow)
 background: -linear-gradient(red, yellow)
}
---------------------------------------------
MIXINS AND DEFAULT VALUES

    Mixin parameters can have default values
in case they have a default value. 
--------------------------------------.scss --
@mixin border-rad($radius: 10px) {
   border-radius: $radius;
}
.border {
  @include border-radius; //this will default
                          //to 10px
}
----------------------------------------------
now, you can always override default values by
entering a variable that's different.

MIXINS FACTS: 
1. Mixins can take multiple arguments.
2. Sass allows you to explicitly define each 
   argument in your @include statement.
3. When values are explicitly specified you 
   can send them out of order.
4. If a mixin definition has a combination of 
   arguments with and without a default value, 
   you should define 
   the ones with no default value first.
5. Mixins can be nested.

Here are some examples of those facts: 

-------------------------------------.scss ------
@mixin dashed-border($width, $color: #FFF) {
  border: {
     color: $color;
     width: $width;
     style: dashed;
  }
}

span { //only passes non-default argument
    @include dashed-border(3px);
}

p { //passes both arguments
    @include dashed-border(3px, green);
}

div { // out of order but explicitly defined
   @include dashed-border(color: purple, 
    width: 5px); 
}
-------------------------------------------------







///////////////////////////////////////////////
        6. THE & CHARACTER 

    The & selector is a sass constructor. 
It's basically sass's version of 'this' and
its used with pseudo-classes.
-------------------------------------- .scss - 
.notecard {
  color: red;
  &:hover{ 
    color: blue;
  }
}
---------------------------------------------
Since the & is in the nested element, it refers 
to the parent, in this case the .notecard class.
It compiles in css to the following:
 ------------------------------------- .css -
.notecard {
  color: red;
}  
.notecard:hover{ 
  color: blue;
}
 ---------------------------------------------
much more efficient, just don't forget the :





///////////////////////////////////////////////
        7. LISTS AND MAPS AS VARIABLES

     Sass allows you to pass maps and lists as
variables:  
-------------------------------------- .scss - 
$college-ruled-style: ( 
    direction: to bottom,
    width-percent: 15%,
    stripe-color: blue,
    stripe-background: white
);  //this map holds all variables for stripes

 @mixin stripes($direction, $width-percent, 
  $stripe-color, $stripe-background: #FFF) {
  background: repeating-linear-gradient(
    $direction,
    $stripe-background,
    $stripe-background ($width-percent - 1),
    $stripe-color 1%,
    $stripe-background $width-percent
  );
}   //this mixin's parameter order match 
    //match $college-ruled-styled

.definition {
      width: 100%;
      height: 100%;
      @include stripes($college-ruled-style...);
 } //DO NOT FORGET the "..." no space
---------------------------------------------
It's very simple, just don't forget to add the 
"..." immediately the map variable 





///////////////////////////////////////////////
            8. STRING INTERPOLATION

    String concatenation isn't the only way to
add a variable to a string, you can also use 
interpolation: 
-------------------------------------- .scss - 
 @mixin photo-content($file) {
  content: url(#{$file}.jpg); 
  //that #{variable} is string interpolation
  object-fit: cover;
}

.photo { 
  @include photo-content('titanosaur');
  width: 60%;
  margin: 0px auto; 
  }
---------------------------------------------
So now the word "titanosaur" is passed as an 
argument/variable into a string that tells the
css what the jpg file name is.





///////////////////////////////////////////////
            9.SASSY FUNCTIONS
    Sass can use functions, and if you ever learn
Ruby, you can even write your own. Here are a few
built in functions you can use: 

-fade-out  
    fade-out makes a color more transparent by 
taking a number between 0 and 1 and decreasing 
opacity, or the alpha channel, by that amount.
--------------------------------------------------
  $color: rgba(39, 39, 39, 0.5);
   $amount: 0.1;
   $color2: fade-out($color, $amount);
   //rgba(39, 39, 39, 0.4) 
--------------------------------------------------

-fade in
    Does the opposite thing as fade-out
-------------------------------------------------
$color: rgba(55,7,56, 0.5);
$amount: 0.1;
$color2: fade-in($color, $amount); 
//rgba(55,7,56, 0.6)
-------------------------------------------------




































