/////////////////////////////////////////////////
WIDTH OF MINI PI SCREEN

/////////////////////////////////////////////////
        CH1- WHAT IS THE SHELL?
 -When we talk about the command line we are 
  really referring to the "shell" which is a 
  program command that takes keyboard vommands 
  and pass them to the OS to carry out.
 -Almost all linux distrobutions support the 
  shell program "bash", which is provided by the
  GNU project
 -Bash stands for "bourne again shell" since
  it replaces the unix shell program "sh" by
  Steve bourne

**terminal emulators**
 -when using a gui, you need a "terminal emulator
  to interact with the shell.
  -KDE uses "konsole" and GNOME uses "gnome-
   terminal" (likely just labeled "terminal")
 -there are many types to choose from


**your first keystrokes**
 -the input prompt in a terminal is called a 
  shell prompt
 -usually its your username, machine name, and
  current working directory, but it can be edited

    mike@linux-machine ~$ 

 -if the last character is a # not $,
  the terminal has "superuser" priveleges" so
  you have administrator priveleges


**command history**
 -press the up arrow to see the previous command 
  entered. most linux distros save the last 500
  commands entered by default
 -use up and down arrows to navigate


**cursor movement**
 -use the arrow left and right keys to move along
  and edit commands
 -you can use the mouse with the terminal 
  emulator, the X window system events supports
  a quick copy paste mechanic. If you left click
  and drag over words, X copies them into a 
  buffer. click down with the middle mouse button
  to paste
 -ctl c and ctrl v don't work to copy and paste
  in some terminals
 -in ubuntu you can use shift ctrl c and v 
 -your GUI probably has a "focus policy" set to
  "click to focus" to match Windows, but X can
  set it to "focus follows mouse" which allows 
  you to mouse over a program without clicking 
  to add input, and it will come to the front 
  only if you click it
 -find this setting in the config program 
  for your window manager.

**try some simple commands
 -$ cal   
  this displays a calendar of the month
 -$ date
  this displays the current time and date
 -$df
  shows free space on disk drives
 -$free 
  shows free memory

**ending a terminal session**
 -$exit
  closes the terminal emulator

**the console behind the curtain**
 -there are "virtual terminals" running behind 
  the gui scenes in most linux distros
 -these can be accessed by hitting ctrl alt F1 
  through F6
 -to switch between them, usealt f1-f6 
 -to get back to gui, use alt f7
 -NOTE: mini pi seems not to be able to switch
  to all 6 options, but can switch between f1, 3, and 5
  like most systems 
 -also, the ctrl key is only required when switchting
  from the gui to a virtual console, when going from 
  virtual consoles, you only need the alt key  


/////////////////////////////////////////////////
                CH2 NAVIGATION

**understanding the filesystem tree**
 -unix-like systems like linux use a 
  heirarchical directory structure, meaning 
  the "root" directory holds all subdirectories 
 -the root file is just /, as if you wrote root/
 -unlike Windows, which has separate file 
  systems for each storage device, unix and linux
  have all drives on one tree, with the admin
  deciding where on the tree devices and drives
  are "mounted" (stored)
 

**the current working directory**
 -the folder you are in is your "current working
  directory" 
 -$pwd 
  this Prints Working Directory you are in
 -when you first log in to a terminal, you are
  in the home directory (~ is the shorthand for
  /home/[username here]) 
 -each user is given their own home directory 
  and it is the only place they can write files
  without admin priveleges


**listing the contents of a directory**
 -$ls
  lists contents of a directory, more on this 
  in ch3
 

**changing current working directory (cwd)**
 -$cd directory-name
  this changes working directory to new 
  specified directory 
 -the shell prompt will change to reflect your
  new cwd (unless you took it off default)
 -can use either absolute or relative pathnames 
  to move:
 *absolute*:
 -the file location in relation to the root
    
    /home/pi/Desktop/test.txt
 
 *relative*:
 -the relative pathname of a file is the location
  in relation to your cwd
 -there are two symbols you can use with 
  relative pathnames . and ..
 -the . symbol refers to your cwd and the ..
  symbol refers to your cwd's parent directory
 
  cd ./file (file in cwd)
  cd ../file (file in the parent of cwd
 
 -note ./ is almost always omited, if no 
  absolute pathname is given, cwd is implied
 -you can use multiple .. at once 
 
    cd ../../file/goal

 -that takes you up two directories etc.

**facts about filenames**
 -if there's a . in front of a file name, it is 
  hidden. you need to do $ls -a to see them
 -this is done for config and other files, 
  we will do more of this later
 -filenames in linux are case sensitive
 -limit punctuation in filenames to -, _, and .
 -do not use spaces, even though they are 
  technically allowed
 -file extensions don't technically matter either
 you can use any extension you want to name, 
  since programs parse files, not linux itself
 -so a file named "thing" works just as well as
  "thing.txt" as a name


/////////////////////////////////////////////////
        CH3 EXPLORING THE SYSTEM 

**more fun with ls**
 -$ ls 
  shows the contnts of your cwd 
 -$ ls Desktop/folder
  use an argument of a folder name to list out 
  that folders contents without moving your cwd
 -$ ls Desktop/folder Desktop/folder2
  separate folders with spaces to see multiple
  contents   
 -$ ls -l thing.txt
  shows info about the specific file thing.txt
  


**options and arguments**
 -you can alter the effects of commands with 
  options and arguments: 

    $ command -option arguments

 -options alter what the command does and the 
  arguments affect what the command acts on
 -options can be case sensitive, so watch out
 -most options are a dash followed by a letter,
  but there are "long options" which are two 
  dashes followed by words 
 
    ls -a // ls --all 

 -the above options do the same thing 
 -short options can be strung together, just use
  a single dash, then multiple short options: 

    ls -alt // the -a, -l, and -t combined

 -short and long options can be used together if
  you want: 

    ls -alt --reverse 


**common ls options**
  -a, --all
  lists all files, even those that are hidden

  -d, --directory 
  ls normally shows you info on files in a dir, 
  but using -d with -l, you can get info on the 
  directory itself (like permissions and links)

  -F, --classify
  append an indecator character to the end of 
  file names (so directories get a / at the end)

  -h, --human-readable
  list file sizes in things like mb and k instead
  of raw bytes
  
  -l 
  display long format (this gives permeisions,  
  file sizes, owners and more, v useful)

  -r, --reverse 
  display results in reverse order, ls normally
  displays files in ascending alphanumeric order
  unless sorted otherwise

  -S
  sort results by file size

  -t 
  sort by when the last modification was, more 
  recent mods at the top


**a longer look at long format**

drw-r--r--  1 root root  6472 Sep 15 14:04 test
1           2 3    4     5    6            7

 -see below for what each field means 

  1
  Access rights to the file, the first character
  says what type of file it is, a - means a 
  regular file, a d is a directory. the next 3 
  are access rights for the files owner, the 
  next 3 are for members of the files group,
  the last three are everyone else. more in ch9

  2 number of hard links to file 

  3 user name of files owner

  4 name of group that owns the file 

  5 size of file in bytes 

  6 date of the files last modification

  7 name of the file 


**determining a files type with file**
 -since filenames are not required to determine 
  an actual file's filetype (ie a .jpg file might
  not actually containg a JPG file), you can 
  double check with the $file command: 

    $ file picture.jpg
    //picture.jpg: JPEG image data, JFIF standard 1.01

  -the file to analyze is an argument for the 
  command


**viewing file contents with LESS**
 -the less command helps you view text files 
 -text files are just one to one mappings of  
  characters to numbers (each char. is a byte)
 -ASCII and unicode are common text types 
 -the less command takes the file to read as 
  an argument: 
 
    $ less /etc/passwd 

 -less is a play on words, since the old unix 
  program was called "more", both programs are 
  examples of "pager" programs 
**less commands**

  PAGE UP key, b
  back one page 

  PAGE DOWN key, SPACE key
  down one page

  UP ARROW, DOWN ARROW  
  up one line, down one line 
  (there is no cursor, its jsut a page view)

  G, g 
  move to end of file, move to sart of file
  
  /characters 
  search for selected characters 
  n
  go to next character set match
  
  h
  display help screen
 
  q
  quit less 

  -notice the similar commands to vi 


**a guided tour**
 -most linux systems are similar and try to 
  conform to the "linux filesystem heirarchy 
  standard" 
 -below are some brief descriptions of the dirs:

 /
  the root dir, where everything is stored 

 /bin
  contains binaries (programs) that must be 
  present for system to boot 

 /boot 
  comtains the linux kernel, initial RAM disk 
  image, and boot loader 

 /dev 
  linux's philosophy of "everything is a file"
  applies to devices, and here is where the 
  kernel maintains a list of all devices it 
  understands 

 /etc 
  contains all system wide config files, and a
  collection of shell scrips that run at boot

 /home 
  each user gets a dir in /home, and here is 
  where they can write files without admin 
  priveleges. this is a safety feature 

 /lib
  contains shared libraries used by core system
  programs 

 /lost+found 
  used in the case of system corruption events 

 /media 
  on modern linux distros, this contains all 
  mountable devices like CDs and USBs that are 
  mounted automaticaly at insertion 
 
 /mnt 
  on older systems, mountable devices are here

 /opt
  used to install "optional" or commercial 
  hardware 

 /proc
  this is a weird dir, it isn't real, it's 
  virtual and maintained by the linux kernel.
  files are readable and gives a view of the 
  the kernel

 /root 
  home directory for the root account 

 /sbin
  contains "system" binaries, these are programs
  that perfom vital tasks reserved for the super
  user

 /tmp
  used for programs that create temporary files,
  some distros clear this each time on boot 

 /usr
  contains all programs and support files used 
  by regular users

 /usr/bin 
  contains executable programs installed by your
  linux distro, can contain 1000s of programs

 /usr/lib
  shared libraries for /usr/bin

 /usr/local 
  where programs that are not included with your
  distro, but indended for system-wide use are 
  stored. it's empty until admin puts stuff here

 /usr/sbin
  contains more sysadmin programs 

 /usr/share
  contains all shared data used by /usr/bin 
  programs like icons and defualt config files,
  background imgs etc etc

 /usr/share/doc
  the documentation for all /usr packages

 /var
  unlike most static directories, this is where
  variable changing data goes, like email and 
  databases

 /var/log
  log files, need to be a superuser to monitor 
  them


**symbolic links**
 -more later, but basically these are like 
  shortcuts that reference files
 -so if you need to referece a file that keeps 
  getting updated, instead of changing all files
  that reference that file with each update, 
  use a symbolic link, then reference that 
 -this means with each update, you just need 
  to change the symbolic link's destinations 

    file > symbolic link foo > mainfile1.0 

      Add updated version of file:

    file > symbolic link foo > mainfile1.1
                              mainfile1.0
 
 -this also lets you keep older versions for 
  easy rollback in case the new version has bugs
 -hard links are similar but more clunky, more 
  on these in next chapter 


/////////////////////////////////////////////////
  CH4 MANIPULATING FILES AND DIRECTORIES

**wildcards*** 
 -wildcards are special characters that help you 
  select files 
 -using wildcards is known as "globbing"

 *table 4-1 wildcards*
  * = any characters 
  ? = any single character
  [characters] = any characters in set characters
    NOTE: these are not strings, treat them as 
    arrays for finding a single char. in a set
  [!characters] = any NOT in set characters 
  [0-9] = any integer 0 through 9
  [[:class:]] = any char. in a specified class

 *table 4-2 commonly used character classes
  [:alnum:] = any alphanumerica character char.
  [:alpha:] = any alphabetic character
  [:digit:] = any numeral 
  [:lower:] = any lowercase letter
  [:upper:] = any uppercase letter

 -here are some examples: 
  * = all files 
  g* = any file starting with g 
  b* = any .txt file starting with b
  Data??? = files beginning with data and ending 
            with any 3 characters 
  [abc]* = files beginning with a, b, or c
  BACKUP.[0-9][0-9] = beggining with BACKUP 
                      followed by . then any 2 
                      digits
  [[:upper:]]* = any file starting with uppercase
                 letter
  [![:digit:]]* = files not starting with a digit
  *[[:lower:]123] = files ending with a lower
                    case letter OR the numerals 
                    1, 2, or 3

 -NOTE: in unix, you may come across [A-Z] [a-z]
  which work in older linux, but have dif results
  in modern. use the upper and lower classes 
  instead 
 -in a lot of linux distros, wildcards work in 
  gui searches too 


**mkdir -create directories**
 -$ mkdir new1
  the mkdir command creates a new directory
 -$ mkdir new1 new2 new3...
  make multiple at once by giving more than 
  one dir. name 


**cp -copy files and directories**
 -cp can be used in two main ways: copying 
  individual files, or copying files into 
  directories: 
 -$ cp item1 item2 
  this copies item1 to a new file called item2,
  if item2 already exists it gets overwritten
 -$ cp item1 item2 directory1
  this copies as many items into a new directory
 
 *cp options* //just a few of them
  -a, --archive 
    copy files and dir. with all their attributes
    including ownerships and permissions. the 
    default is to copy with the own. and perms.
    of user performing cp
  -i, --interactive
    before overwriting an existing file, 
    ask permission, default is to do it silently
    (as in not ask for permission)
  -r, --recursice
    recursively copy directories and their 
    contents. this or -a is required when 
    copying dir.
  -u, --update 
    when copying files from one directory to 
    another, only add the files that either 
    exist or are newer versions 
  -v, --verbose 
    display info messages as it does stuff
    these are not confirmations, just messages 
    that alert you to what step of the 
    process you are in

  *cp examples*
  cp file1 file2
    copies file, if fil2 exists it's overwritten
  cp -i file1 file2 
    if file2 exists, it asks for confirm 
    of overwrite 
  cp file1 file2 dir1
    copy files to directory
  cp dir1/* dir2
    use a wildcard to copy each file from 
    dir1 into dir2 
  cp -r dir1/ dir2
    same effect as above
  cp -r dir1 dir2
    copies the directory and its files (not just
    the loose files) into dir2. if dir2 does not
    exist, then it is created, and the loose 
    files inside dir1 will be in dir2 (without 
    being contained in dir1)
  cp /home/file1 . 
    copy file from another dir. into your cwd
    (use -r if it's a directory your copying)

**mv -move and rename files**
 -use mv to move and rename files:
 -$ mv item1 item2
  now item1 is called item2, if item2 exists it 
  is overwritten by item1. either way, item1 is 
  no longer a thing 
 -$ mv item1 dir1
  now item1 is in dir1 instead of where it was 
 *mv options*
  -i, --interactive
    same thing as cp's version
  -u, --update
    when moving files to new dir, it only moves 
    files that dont exist or are newer than the 
    dir's version
  -v, --verbose 
    same thing as usual 
  NOTE: you do not need to use -r ever with mv, 
    since it is basically designed to work with
    directories 

 *mv examples*
    mv file1 file2
      renames/overwittes file1 to be file2 (this
      works on files and directories)
    mv -i file1 file2
      if file2 exists, must confirm overwrite
    mv file1 file2 dir1
      move files to dir1 (any number of files)
    mv dir1 dir2
      move dir1 into dir2, if dir2 does not 
      exist, you have to make it first, otherwise
      this will just rename dir1 to dir2


**rm -remove files and directories**
 -$ rm item1 item2 ite...
  this permanently deletes the file 
 -BE FUCKING CAREFUL rm is instant and permanent
  if you are using wildcards, test it with ls 
  first to see what files you are deleting since:
  
    $ rm *.html
    $ rm * .html
  
  the second one will accidentally delete every
  file in your cwd then complain that there is 
  no file called ".html" to delete

 *rm options*
  -i, -interactive 
    same as usual
  -r, --recursive 
    needed for directories, same as usual
  -f, --force
    ignore nonexistent files and do not prompt
    this overrides the -i option
  -v, --verbose 
    display messages as usual 

 *rm examples*
  rm file1
    removes file
  rm -i file1
    asks for confirm before deletion
  rm -r file1 dir1 
    -r lets you delete directories 
  rm -rf file1 dir1
    same as above, but now if one of those 
    files doesn't exist, rm will continue 
    silently (otherwise it sends a little 
    warning message about the error even though
    both styles delete any real files they find)
  

**ln -create links**
 -create either hard of symbolic links with ln:
 -$ ln file link //hard link
 -$ ln -s file-or-dir link //symbolic links
  // ln test.txt hard //hard is the name of link
  // ln -s tip.txt sym //sym is the name of link
 -hard links are the original way to make links
  in unix. A link is just a new directory entry
  for a file. So instead of copying a file and 
  all it's space, a link is the same file that 
  can now be accessed from more than one  
  location on your computer
 -hard links can't reference a directory and they
  cant reference a file outside their disk 
  partition as the link itself 
 -links of both types can't have the same name 
  as a pre existing file or link. to overwrite
  a file/link to become a new link, you need to 
  use the -f (--force) option. 
 -symbolic links are the new way to make links 
  they can reference directories now 
 -another difference between symbolic and hard
  links is how they treat the deletion of the 
  file they link to: 
    -hard links literally ARE the file, so 
     the original file contents will not be 
     removed until all hard links are removed
    -symbolic links are just pointers, so if the 
     original file gets deleted, the link is 
     said to be broken and will come up as an 
     error (ls will ussually display them in 
     different colors once broken)
 -the links will act like what they are linking
  to, so if you link a file, you can edit the
  file or the link and both change. If the 
  symbolic link is to a directory, you can cd 
  into the dir. and it will contain the same 
  files as the original 
 
**telling links apart from sources**
 -symbolic links are obvious, when you ls -l, 
  they have an arrow from the link to the source
  file
 -hard links are harder, they don't look any 
  different from a regular file, to spot a 
  hard link, use ls -i, that -i shows each 
  file's "inode" (often used with -l option) 
 -to think about it in another way, all files 
  have 2 parts, a data part which holds the files
  content and a name part, which hold the file's 
  name and meta data. when you create a hard link
  your creating an additional name part that 
  refers to the same content
 -an inode is a chain of disk blocks that the 
  system assigns to it 
 -to find all links to a file, search for the 
  inode: 

    $ find ~/ -xdev -inum [inode num here]

**creating symlinks with the gui**
 -you can make symlinks in linux guis
 -usually there will be an option in the drop
  down menu when you right click an item, in 
  GNOME you hold ctrl+shift while dragging 
 -ubuntu, ctrl + drag + shift and then drop the
  now symbolic link where you want it (ctl + drag
   is how to make a copy of a file in the gui)



/////////////////////////////////////////////////
        CH5 WORKING WITH COMMANDS 
**what exactly are commands**
 -they are one of 4 things:
  -an executable program:
   like the files we saw in /usr/bin, they are 
   either "compiled binaries" written in C, c++
   or programs written in scripted languages like
   python, perl, ruby etc
  -a command built into the shell itself:
   bash supports a bunch of built in commands
   called "shell builtins" cd is this 
  -a shell function:
   "shell functions" are mini shell scripts built
   right into the environment
  -an alias 
   "alias" is a command that we configured 
   ourselves


**identifying Commands**
 -use $ type to figure out which of the 4 types 
  a command is: 
  
  $ type ls
  ls is /bin/ls
  $ type cd
  cd is a shell builtin
  $ type ll
  ll is aliased to 'ls -alt'

 -we can see some exampls, ls and cd, though they
  look similar, are actually different types 
 

**which -display an executables location
 -sometimes more than one version of an 
  executable is on a system, so to know the
  exact location of the exectuable use which: 

    $ which ls
    /bin/ls

 -only works on executables, but on macs, it 
  might work on other types of commands as well
  on linux it will give an error or no response


**Getting a commands documentation**
 -bash has help pages for each of the shell 
  builtins 

    $ help cd 
    //a bunch of stuff 

 -NOTE: when square brackets appear, they show 
  optional items, the | indicates mutally 
  exclusive terms 
 
  [-L|-D] [dir] 
 
 -the above means either L or D, then dir

 -for executable programs, use --help 

  $ mkdir --help 
  //bunch of stuff 

 -some programs dont support --help, but if you
  try --help, most cases the error message will 
  list all the options you'd need anyway


**man -display a programs manual page**
 -use: 

  $ man ls 
  $ man 5 ls

 -the first one opens up the full man page for 
  the command, the second opens only up one 
  section. the 8 possible section are below. 
  Not every command has every one of the sections
 -note: man stands for manual 

  1 user commands
  2 proframming interface for kernal system calls
  3 programming interface for C library
  4 special files for device nodes and drivers
  5 file formats
  6 games and extra fun stuff
  7 miscellaneous
  8 system admin commands 


**apropos -display approtiate commands**
 -search the man pages for a word, very crude but
  it can come up with relevant commands 

  $ apropos web
  cheese (1)  -details about program
  firefox(1)  -details about program
  //more programs 

 -the first field is the command, the second is
  the section the word comes up in first 
 -NOTE $ man -k  does the same thing as apropos


**whatis -display a brief description**
 -get a brief description of command: 

    $ whatis ls 


**info -display program's info entry**
 -the GNU project has an alternative to man pages
  called "info pages" and you read them with the 
  info program
 -the info pages are called info files, with 
  tree structures and each 'node' contains a 
  single topic. 
 -the notes are hyperlinked like webpages 
  
    $ info ls 

 -here are the info commands:
  ?   -display command help
  PAGE UP or BACKSPACE
    display previous page
  PAGE DOWN or SPACEBAR
    display next page
  n
    Next -display next node
  p
    Previous -diplay previous node
  u
    up- display parent node 
  ENTER
    follow hyperlink under cursor
  q
    quit 


**README and other program documentation**
 -most documentation is in /usr/share/doc
 -most are plaintext, so you can be viewed with 
  less
 -some are .html so view them as with browsers
 -some are .gz files, which have been compressed
  with the gzip compression, which you view with
  the zless program, which views compressed files
  

**Creating your own commands with alias**
 -it is possible to put more than one command
  on a line: 

    $ cd ..; ls; cd -

 -simply separate each command with a semicolon
  and a space 
 -alias lets you turn a sequence of commands or 
  a long command into a short cut that you can 
  type instead 
 -before making an alias, use type to check
  
  $ type test
  test is a shell builtin
  $type foo
  bash: type: foo: not found 

 -so like, test would be bad since it's taken, 
  but foo would be fine
 -you make a foo like this: 

    alias foo="cd /usr; ls; cd -"
    alias name="actual command in quotes"

 -you can now just type foo to get those 3 ones 
 -if you use the type command on foo, now it says
  
    $ type foo
    foo is aliased to 'cd /usr; ls; cd -'

 -you can also use an alias to override a command
  that does exist, if you want.
 -to see all aliases set up in your environment,
  just type alias into the command line 

    $ alias 


/////////////////////////////////////////////////
      CH6 REDIRECTION

 -i/o stands for input/output
 -with this facility you can redirect the input 
  and output of commands to and from files, 
  as well as connect multiple commands 
  to make powerful "command pipelines."

**Standard Input, Output, and Error**
 -many of the programs we've been using have 
  2 types of output, first the programs results,
  and second, the status and error messages 
 -in Unix, "everything is a file" so things like 
  ls actually send their results to a special 
  file called "standard output" (stdout) and 
  their status/error messages to a file called
  standard error (stderr)
 -by defualt, both files are linked to the screen
  and not saved to disk
 -in addition, programs take input from a
  facility called standard input (stdin)
 -I/O redirection allose us to change where this
  all works and goes 


**Redirecting Standard Output**
 -to redirect standard output to another file 
  use  the rediection > operator 

    $ ls -l /usr/bin > ls-output.txt

 -this redirects the output into the file 
  ls-output.txt, if the file does not exist it 
  is created 
 - the > operator overwrites a file, so if there
  is no output, it will create a blank file (or 
  truncate an existing file and making it empty)

    $ > test.txt 
  
 -this is a quick way to create a new file 
 -to append more data onto the end of a file, 
  use the >> operatror 

    $ ls -l /usr/bin >> ls-output.txt


**Redirecting Standard Error**
 -the thre file streams, stdin, stdout, stderr
  the shell references them internally as file 
  descriptors 0, 1, and 2 respectively
 -to redirect an error/status message to a file 
  use the shell reference before the operator:
  
    $ ls -l /bin/usr 2> ls-error.txt

 
**Redirecting stdout and stderr to One File**
 -this is the old way to output both to a file

    $ ls -l /bin/usr > ls-output.txt 2>&1

 -note the order: stderr must be redirected 2nd
  otherwise it will output to the screen 
 -Below is the modern way to do this: 

    & ls -l /bin/usr &> ls-output.txt


**Disposing of Unwanted Output**
 -to simply throw away output or errs, you can
  send the them to the "bit bucket" which is 
  /dev/null 
 -the system accepts the input and then just 
  does nothing with it 
 -this example silences error messages: 

    $ ls -l /bin/usr 2> /dev/null 

 -in unix culture, this is slang for throwing
  away an idea 


**Redirecting stdin**
 -cat -concatenate files 
  the cat command reads one or more files 
  and copies them to standard output: 

    $ cat ls-output.txt
 
 -this displays the file, often used to show 
  small text files
 -it can also take more than one argument, 
  so it is also used to join multiple files
  together: 

    $ cat movie.mpeg.0* > movie.mpeg

 -since wildcards expand in order, that will  
  combine all the ordered mpeg files and 
  stitch them together
 -if cat is given no arguments, it will instead
  read from standard input 
 -so it will take what you type below it and 
  then output it, OR put it into a file 
  if you redirected it 
 -to stop the stdin, use the ctl-D interrupt 
  to tell cat is has reached end-of-file (EOF)
  of stdin
 
    $ cat > lazy_dog.txt
    words words words 
    $ cat lazy_dog.txt
    words words words 

 -you can also redirect the input of cat as 
  a file by using the < operator: 

    $ cat < lazy_dog.txt
  
  -this doesn't do much, but it shows that 
  you can redirect input 



**Pipelines**
 -The ability of commands to read data from 
  standard input and send to standard output 
  is utilized by a shell feature called 
  pipelines.
 -Using the pipe operator | (vertical bar), 
  the standard output of one command can be 
  piped into the standard input of another.
  
    $ ls -l /usr/bin | less

 -you can use many pipelines back to back


**Filters**
 sort
  
    $ ls /bin /usr/bin | sort | uniq | less

 -the sort command creates a single sorted list
 -here are some good options: 
   -f, --ignore-case
    use this so that it ignores captials
    (default is to put all captials first, then
    lower case)
   -g, --general-numeric-sort
   -b, --ignore-leading-blanks
              ignore leading blanks
   -d, --dictionary-order
              consider only blanks and alphanu-
              meric characters
  See the man page for more 


  uniq -report or omit repeated lines 
 -uniq is used in conjution with sort since 
  uniq removes the 2nd back to back repeated 
  line 
 -if the lines are not next to each other,
  the duplicate will not be recognized
 -if you want ONLY the duplicates in a file, 
  use the -d option 

    $ ls /bin /usr/bin | sort | uniq | less
    //removes duplicates 
    $ ls /bin /usr/bin | sort | uniq -d | less
    //shows only duplicates 

  wc—Print Line, Word, and Byte Counts
 -The wc (word count) command is used to display
  the number of lines, words, and bytes 
  contained in files. For example:
  
    $ wc ls-output.txt
    7902 64566 503634 ls-output.txt
    //lines, words, and bytes in file 

  use wc -l, for just lines, wc -c for just 
  bytes, and wc -w for just words 
 -if no file is specified, it will just work on
  the keyboard input like cat, until EOF is 
  given
 -lines start at 0 for wc 


**grep—Print Lines Matching a Pattern**
 -grep is a powerful program used to find text 
  patterns within files, like this:
    
    $ grep pattern [file...]
  ls /bin /usr/bin | sort | uniq | grep zip
  //searches our list and reprints any line with
  //"zip" in it 

 -grep -i is case insensitive and grep -v 
  prints only lines that DON'T match the pattern


**head/tail—Print First/Last Part of Files**
 -head outputs the first 10 lines of a file, 
  and tail outputs the last ten, use -n option
  to modify the number of lines you want: 

    $ head -n 5 ls-output.txt
    $ tail -n 5 ls-output.txt

 -tail has an option that lets you see the 
  lines in real time, .eg see log lines as 
  they are printed. use -f option 

    $ tail -f /var/log/messages

 -tail will continue to monitor and print until 
  you use ctrl-C interupt


**tee—Read from Stdin and Output to Stdout and Files**
 -the tee command is like a t pipe in plumbing 
 -the tee program reads the standard input, 
  then copies it to one or more files AND 
  stdout for the next command: 

  $ ls /usr/bin | tee ls.txt | grep zip

 -so before out grep output is printed to the 
  screen, tee copies the grep input to a file 
  that is just the ls /usr/bin output



////////////////////////////////////////////////
   CH7 SEEING THE WORLD AS THE SHELL SEES IT

**Expansion**
 -when you hit enter in bash, it carries out 
  several processes on the text before it 
  carries out your command 
 -this is called "expansion", it's what happens
  with * for example

**echo command**
 -echo is a shell builtin that prints text 
  arguments on stdout 

**expansion (cont)**
 -so look at these two examples:

    [me@linuxbox ~]$ echo this is a test
    this is a test
    [me@linuxbox ~]$ echo *
    Desktop Documents ls-output.txtdd etc etc 
    //pretend i wrote all files

 -in this instance the shell expanded * to 
  be "match any characters in a file name" which
  then printed each file name in your cwd 
 -when enter is pressed, expansion occurs, so 
  echo never even saw the * 


**Pathname Expansion**
 -The mechanism by which wildcards work is 
  called pathname expansion.
 -you can get creative with how you do this: 

  echo *s
  echo D*
  echo [[:upper:]]*
  echo /usr/*/share
  ls -d .[!.]?* //shows hidden files, not includ                // the . and .. symbols 


**Tilde Expansion**
 -the ~ character expandes do the home dir of 
  the named user, or ~user to expand to the 
  home dir of specified user

    $ echo ~
    /home/me
    $ echo ~foo
    /home/foo

**Arithmetic Expansion**
 -you can do some basic math with expansion:

    $ echo $((2 + 2))
    //$((expression)) is the expansion part 

 -you can do +, -, *, / 
 -NOTE expansion only supports integer 
  arithmetic, results are integers 
 -modulo %, and exponention ** work as well
 -spaces INSIDE the expression do not matter 
  and you can nest: 

    $ echo $(($((5**2)) * 3))

 -but you can also use parentheses like normal: 
  
    $ echo $(((5**2) * 3))

 -heres an example of what integer div will do:

    $ echo Five divided by two equals $((5/2))
    Five divided by two equals 2
    $ echo with $((5%2)) left over.
    with 1 left over.


**Brace Expansion**
 -brace expansion is weird but very powerful
 -it's kind of like a primitive for loop: 

    $ echo Front-{A,B,C}-Back
    Front-A-Back Front-B-Back Front-C-Back

 -the patterns inside the braces, separated by
  commas NOT spaces, will print one at a time 
 -you may have a "preamble" and "postscript" 
  connected to the space. NO SPACES 
 -the braces may contain, list of comma
  separated strings, or a range of integers 
  or single characters: 

    $ echo Number_{1..5}
Number_1 Number_2 Number_3 Number_4 Number_5
    $ echo {Z..A}
Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
    $ echo a{A{1,2},B{3,4}}b
    aA1b aA2b aB3b aB4b

  -you can also use braces in braces as above
  or multiple braces as multiple arguments 

  $ mkdir {2009..2011}-0{1..9} {2009..2011}-{10..12}
  $ ls
2009-01 2009-07 2010-01 2010-07 2011-01 2011-07
2009-02 2009-08 2010-02 2010-08 2011-02 2011-08
2009-03 2009-09 2010-03 2010-09 2011-03 2011-09
2009-04 2009-10 2010-04 2010-10 2011-04 2011-10
2009-05 2009-11 2010-05 2010-11 2011-05 2011-11
2009-06 2009-12 2010-06 2010-12 2011-06 2011-12

  -this is most helpful for making files and 
  directories quickly 


**parameter expansion**
 -parameter expansion shows you certain 
  variables that are saved in your environement 
  
    $ echo $USER
    mike
    
 -to quickly see all environment variables use 
  the printenv command (with less for ease):

    $ printenv | less 

 -parameter expansion is case sensitve 


**command substitution**
 -use $(command) to deal with the output of a 
  command as an expansion: 

    $ ls -l $(which cp)
    -rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp

 -that one is great because it gives you details
  on a dir without having to know the full 
  pathname 
 -you can use pipelines as well 
  
  $ file $(ls /usr/bin/* | grep zip)

 -older shells used ` back quotes (on the tilde
  key) instead, like so: 

    $ ls -l `which cp`


**quoting**
 -word splitting is when the shell removes 
  extra white space: 

    $ echo this is a       test
    this is a test

 -parameter expansion can also cause issues: 

    echo The total is $100.00
    The total is 00.00

 -it will try to fine the variable $1, come up
  with nothing, then print the rest 
 -to get around these issues, use " or ' 


**double quotes**
 -with double quotes, all special characters are
  ignored except $, \, and `
 -good for filenames with spaces 

    less "two words.txt"
 
 -note: Parameter expansion, 
  arithmetic expansion, and command substitution
  still take place within double quotes:

    $ echo "$USER $((2+2)) $(cal)"
    me 4 February 2012
    Su Mo Tu We Th Fr Sa
    1 2 3 4
    5 6 7 8 9 10 11
    12 13 14 15 16 17 18
    19 20 21 22 23 24 25
    26 27 28 29

 -word splitting looks for presence of spaces,
  tabs, newlines, and treats them as 
  "delimiters" 
 -since they are condidered as spaces, not text,
  the shell ignored them. with "" these spaces
  become a part of a single argument 
 -this is most notable with cal: 

  [me@linuxbox ~]$ echo $(cal)
  February 2012 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
  [me@linuxbox ~]$ echo "$(cal)"
    February 2012
  Su Mo Tu We Th Fr Sa
  1 2 3 4
  5 6 7 8 9 10 11
  12 13 14 15 16 17 18
  19 20 21 22 23 24 25
  26 27 28 29

 -without quotes, each number is treated as it's
  own arg. with the echo command, with quotes,
  the whole cal and it's newline characters are
  treated as a single argument and printed in 
  the proper format 


**single quotes**
 -single quotes supress all expressions 
 -here's the difference between them all: 

$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
text /home/me/ls-output.txt a b foo 4 me
$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
text ~/*.txt {a,b} foo 4 me
$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER


**escaping characters**
 -if you only want to ignore one character at a 
  time, you can use the backslash \ called the
  escape character: 

    $ mv bad\&filename good_filename
    //that ignores the & symbol
    $ echo "The price for user $USER is: \$5.00"
    The price for user me is: $5.00
    //notice the $ for 5 is escaped, but not 
    //for $USER so we can see which user 


**Backslash escapse sequences**
 -the \ is also used to represent special 
  characters called "control codes" like tabs 
  and new lines or alerts 
 -the first 32 char. in ASCII are used to 
  transmit commands to teletype like devices 
 -here are some common ones you'd know: 

  \a =Bell (“alert”—causes the computer to beep)
  \b =Backspace
  \n =Newline (on Unix-like systems, 
    this produces a linefeed)
  \r =Carriage return
  \t =Tab

 -to used them, use echo -e and then put the 
  escape sequences in double or single quotes: 

    $ sleep 10; echo -e "Time's up\a"
    $ sleep 10; echo "Time's up" $'\a'


////////////////////////////////////////////////
        CH8 ADVANCED KEYBOARD TRICKS
 
**Command Line Editing**
 -bash uses a library (a shared collection 
  of routines that different programs can use) 
  called Readline to implement command line 
  editing.
 -here are some of the most useful hotkeys: 
 -NOTE: some of these might get intercpeted 
  weirdly with your GUI, but if you use 
  virtual terminals, they should all work 
  perfectly

**Cursor Movement**
  Table 8-1: Cursor Movement Commands
Key     Action
CTRL-A  Move cursor to the beginning of 
        the line.
CTRL-E  Move cursor to the end of the line.
CTRL-F  Move cursor forward one character; 
        same as the right arrow key.
CTRL-B  Move cursor backward one character; 
        same as the left arrow key.
ALT-F   Move cursor forward one word.
ALT-B   Move cursor backward one word.
CTRL-L  Clear the screen and move the cursor 
        to the top left corner. The clear 
        command does the same thing.

**Cutting/Pasting (Killing/Yanking) Text**
 -Readline refers to cut/pase as kill/yank 
 -items that are cut are stored in a buffer 
  called the "kill-ring"
 -here are the main commands: 

**Table 8-3: Cut and Paste Commands**
Key     Action
CTRL-K  Kill text from the cursor location to 
        the end of line.
CTRL-U  Kill text from the cursor location to 
        the beginning of the line.
ALT-D   Kill text from the cursor location to 
        the end of the current word.
ALT-BACKSPACE   Kill text from the cursor 
                location to the beginning of 
        the current word. If the cursor is at 
        the beginning of a word, kill the 
        previous word.
CTRL-Y  Yank text from the kill-ring and 
        insert it at the cursor location.

**Table 8-2: Text Editing Commands**
Key     Action
CTRL-D  Delete the character at the cursor 
        location.
CTRL-T  Transpose (exchange) the character at 
        the cursor location with the one 
        preceding it.
ALT-T   Transpose the word at the cursor 
        location with the one preceding it.
ALT-L   Convert the characters from the cursor 
        location to the end of the word to 
        lowercase.
ALT-U   Convert the characters from the cursor 
        location to the end of the word to 
        uppercase.


**The Meta Key**
 -basically, old terminal keyboards were all 
  differenct, so the ASCII standard didn't call
  for specific control keys, but called for 
  a single "meta" key that would function as 
  intended. Now, it ussually refers to the 
  alt key


**Completion**
 -hit tab to autocomplete the first command on 
  a line, then any files. you have to give 
  enough of a clue so that only one file will
  match it 

  $ ls l (hit tab, and you'd get list.txt)

 -completion works on hosts in /etc/hosts, 
  commands, usernames, and variables 

  Table 8-4: Completion Commands
  ALT-?, tab-tab 
    Display list of possible completions. 
    On most systems you can also do this by 
    pressing the TAB key a second time, which is
    much easier.

  ALT-* 
    Insert all possible completions. This is 
    useful when you want to use more than one 
    possible match.

 -you can create your own completion rules, this
  is called "programmable completion" ubuntu 
  has a lot and you can see it by $ set | less


**using history**
 -your history is saved in ~/.bash_history 

**searching history**
  $ history | less
    -good way to search history and will show 
     you the line number of each command from 
     the last 500 (or more if you specified)
  $ history | grep /usr/bin
    -search history using grep 
  $ !88
    -this will expand the command on line 88 
    of your history

 -you can search your history incrementally,
  as each character enters the search is refined
 -to start, hit ctrl-R and start typing
 -when you fined the command you want, type 
  ENTER or ctrl-J to copy the line from your 
  history to ythe current command line  

    (reverse-i-search)`': 
    //as you type, it appears between ` and '
    (reverse-i-search)`ls >': ls > thing.txt 

  Table 8-5: History Commands
  CTRL-P 
    Move to the previous history entry. 
    Same action as the up arrow.
  CTRL-N i
    Move to the next history entry. 
    Same action as the down arrow.
  ALT-< 
    Move to the beginning (top) of the 
    history list.
  ALT-> 
    Move to the end (bottom) of the 
    history list; i.e., the current command line
  CTRL-R 
    Reverse incremental search. Searches 
    incrementally from the current command line 
    up the history list.
  ALT-P 
    Reverse search, non-incremental. With this 
    key, type the search string and press ENTER 
    before the search is performed.
  ALT-N 
    Forward search, non-incremental.
  CTRL-O 
    Execute the current item in the history list
    and advance to the next one. This is handy 
    if you are trying to re-execute a sequence 
    of commands in the history list.


**history Expansion**
 -using the ! you can expand items in the 
  history, there are more options below,
  but be careful using the !string !?string 
  options unless you really know what's in your
  history: 

  Table 8-6: History Expansion Commands
  !! 
    Repeat the last command. It is probably 
    easier to press the up arrow and ENTER.
  !number 
    Repeat history list item number.
  !string 
    Repeat last history list item starting 
    with string.
  !?string 
    Repeat last history list item containing 
    string.


**script**

  $ script [filename]

 -the script command saves your entire shell 
  session in a file. if no filename is given it 
  will create a file called "typescript" in 
  your home directory
 -it works in linux, in mac, it starts a record
  from that moment, then saves it. linux way is 
  retro active 


/////////////////////////////////////////////////
              CH9 PERMISSIONS 

 -unix is designed to be multi-task and 
  multi-user, unlike MS-DOS, which was just 
  multi task 
 -so things like remote access with ssh are 
  possible, becuase back in the day, there was 
  one main computer with many terminals 
 
**Owners, Group Members, and Everybody Else**
 -in unix, users can own files and directories 
  and belong to a group of one or more users who
  are given access to those files and dirs 
 -an owner can grant access to other people 
 -use the id command to find info about your 
  currnt user identity: 

  [me@linuxbox ~]$ id
  uid=500(me) gid=500(me) groups=500(me)

 -when user accounts are created, they are given
  assigned a user ID (uid) 
 -the user is also assigned to a primary group id
  (gid) 
 -there meay be other groups assigned to
 -this looks a little different with each distro
  the above is fedora, below is ubuntu: 

[me@linuxbox ~]$ id
uid=1000(me) gid=1000(me)
groups=4(adm),20(dialout),24(cdrom),25(floppy),
29(audio),30(dip),44(video),46(plugdev),
108(lpadmin),114(admin),1000(me)

 -notice the uid's are different, fedora starts 
  at 500 while ubuntu starts at 1000, ubuntu
  has way more groups because it manages 
  permissions differently
 -all this data is in the following files: 
  -/etc/passwd -where user accounts are defined
  -/etc/group  -where groups are defined 
  -/etc/shadow howld info on users passwords 

 -for each user account the /etc/passwd file 
  defines the user (login)name, the uid, gid, 
  the accounts real name, home dir., and login
  shell
 -notice there are many other users and the 
  superuser has a uid of 0 
 -more on this is chapter 10


**Reading, Writing, and Executing**
 -Access rights to files and directories are 
  defined in terms of read access, write 
  access, and execution access.
 -we see this with ls -l: 

-rw-rw-r-- 1 me me 0 2012-03-06 14:52 foo.txt
12  3  4
    1- spot is file type
    2- 2nd three are owner permissions 
    3- next 3 are group permissions 
    4- the last three are world permissions 

 -below is a table of each symbol/letter meaning:
  
  
**Table 9-1: File Types**
 - 
  a regular file 
 d 
  a directory
 l 
  A symbolic link. Notice that with symbolic 
  links, the remaining file attributes are always
  rwxrwxrwx and are dummy values. The real
  file attributes are those of the file the 
  symbolic link points to.
 c
  A character special file. This file type refers
  to a device that handles data as a stream
  of bytes, such as a terminal or modem.
 b
  A block special file. This file type refers 
  to a device that handles data in blocks, 
  such as a hard drive or CD-ROM drive.


**Table 9-2: Permission Attributes**
  r 
  -file:
    Allows a file to be opened and read. 
  -dir:
    Allows a directory’s contents to be listed if
    the execute attribute is also set.
  w 
  -file:  
    Allows a file to be written to or truncated;
    however, this attribute does not allow files 
    to be renamed or deleted. The ability to 
    delete or rename files is determined by 
    directory attributes.
  -dir:  
    Allows files within a directory to be 
    created, deleted, and renamed if the 
    execute attribute is also set.
  x 
  -file:
    Allows a file to be treated as a program
    and executed. Program files written in 
    scripting languages must also be set as 
    readable to be executed.
  -dir:
    Allows a directory to be entered; e.g.,
    cd directory.


**chmod -Change File Mode**
 -use chmod to change the permissions of a 
  file or dir. 
 -only the owner or the superuser can modify 
  a file/dir
 -chmod supports 2 ways of changing: octal or 
  symbolic


**octal representation**
 -octal noation uses octal digits to set the 
  permission
 -since each octal digit represents 3 binary 
  digits, it works well. here's a table:

  Table 9-4: File Modes in Binary and Octal
    Octal Binary File Mode
      0    000     ---
      1    001     --x
      2    010     -w-
      3    011     -wx
      4    100     r--
      5    101     r-x
      6    110     rw-
      7    111     rwx

 -NOTE: octal means base 8
  and it and hex (base 16) are used largely for 
  human convenience 
 -this is how octal permissions work: 

[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me me 0 2012-03-06 14:52 foo.txt
[me@linuxbox ~]$ chmod 600 foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw------- 1 me me 0 2012-03-06 14:52 foo.txt

 -so for the owner the permission is 6, 
  the group is 0, and world is 0. 
 -it's 3 octal digits together for each group
 -it may seem inconvenient to remember this 
  but you will mainly only use 7, 6, 5, 4, 0


**symbolic Representation**
 -this method uses 3 parts: who the change 
  affects, what operation (add, remove) is being
  used, and what permissions are affected. 
  below are the symbols used

**table 9-5 chmod symbolic notation**
  u
    Short for user but means the file or 
    directory owner.
  g
    Group owner.
  o
    Short for others but means world.
  a 
    Short for all; the combination of u, g, and o

 -if no user is specifed, a is assumed 
 -so you can add (+) take away (-) or set (=)
  specific permission and remove all others
  here are some examples: 
 -think of + - like editing, and = as resetting 
  specifically to exactly what you want


**Table 9-6: chmod Symbolic Notation Examples**
  u+x 
    Add execute permission for the owner.
  u-x 
    Remove execute permission from the owner.
  +x
     Add execute permission for the owner, 
     group, and world. Equivalent to a+x.
  o-rw 
    Remove the read and write permissions from 
    anyone besides the owner and group owner.
  go=rw 
    Set the group owner and anyone besides the 
    owner to have read and write permission. 
    If either the group owner or world previously
    had execute permissions, remove them.
  u+x,go=rx 
    Add execute permission for the owner and 
    set the permissions for the group and 
    others to read and execute. Multiple 
    specifications may be separated by commas.


 -look at chmod's man page for more, but be 
  careful of the recursion option, since it 
  makes both files and directories the same
  which is useless
 -some prefer octal, others symbolic, symbolic
  does offer a less invasive approach


**setting file mode with GUI**
 -jsut right click and it's ussually an option
  to mess with it. in ubuntu it's under 
  properties


**umask—Set Default Permissions**
 -the umask command controls the default 
  permissions given to a file 
 -it uses octal notations to create a mask of 
  bits to be removed from a file's mode 
  attributes (the mask picks what permissions to 
  take away)

[me@linuxbox ~]$ rm -f foo.txt
[me@linuxbox ~]$ umask
0002
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me me 0 2012-03-06 14:53 foo.txt

 -ignore the first zero, those are special 
  permissions, but the last three match user,
  group, and world. as you can see the basic
  mask removes "2" which is write, while 
  not affecting the others
 -you can set the mask, like this, in this 
  case to remove nothing from files: 

[me@linuxbox ~]$ rm foo.txt
[me@linuxbox ~]$ umask 0000
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-rw- 1 me me 0 2012-03-06 14:58 foo.txt

 -NOTE: we removed the file to ensure that 
  the created file doesn't pick up old 
  permission 
 -the basic file without a mask is that all 
  users can read and write the file
 -when you set the mask, it will stay at that 
  value for your session only. you can set it 
  in to stay permanently with bash profiles 


**SOME SPECIAL PERMISSIONS**  
 -so that first zero is for special permissions 
  for the file, here are some examples: 
 4000
  the setuid bit, which makes it so the file, 
  if executable, has the same permissions as the 
  real user, that is the person running the file.
  this is given to superuser files so they have 
  access to whatever the superuser does. this 
  is a security hazard in cases and should be 
  used sparingly
 2000
  this is the setgid bit, and it changes the 
  effective group ID to the file owner. 
  this is handy when sharing a file and all new 
  files need to be accesed by everyone in the 
  group, not just the creator
 1000
  this is the sticky bit, from ancient unix. 
  in linux it is ignored unless it is on a 
  directory. if on a dir. it prevents users from
  deleting or renaming files unles the user 
  is the owner of the directory or file, or the 
  superuser 

 -Here are some examples of using chmod with 
  symbolic notation to set these special 
  permissions. 
  First, assign setuid to a program:
      chmod u+s program
  Next, assign setgid to a directory:
      chmod g+s dir
  Finally, assign the sticky bit to a directory:
      chmod +t dir
  By viewing the output from ls, you can 
  determine the special permissions.

  Here are some examples. First, a program that 
  is setuid:
      -rwsr-xr-x
  Now, a directory that has the setgid attribute:
      drwxrwsr-x
  Finally, a directory with the sticky bit set:
      drwxrwxrwt


***INTERLUDE: adding/deleting users***
 -use the adduser command with either root access
  or the sudo. 
 -remember, in ubuntu you can't function as the 
  root user, so you'll need to use sudo: 

    $ sudo adduser new-user-name

 -you will then be asked for your password to 
  set this up, then for info on this user like
  phone and whatnot, then finally a password for 
  the new user 

 -to delete a user use 

    $ sudo deluser new-user-name

 -however to delete their home directory as well,
  use --remove-home 

    $ sudo deluser --remove-home new-user-name

 -to add a group, use addgroup command

    $ sudo addgroup fun-guys
 
 -to delete a group use: 

    $ sudo delgroup fun-guys 

 -groups are created without any members, so you
  add them with adduser again: 

    $ adduser mike fun-guys
    //ubuntu assigns the GID for you, but you 
    //can assign it yourself with the option

 -to find the members of a group, you can: 
    -use the id command to see what groups the 
      user belongs to
    -use 
      $ grep group-name /etc/group
    -or install the members command
      $ sudo apt-get install members
      $ members group-name 
      






**changing identities**
 -use the su command to become another user 
  and the sudo command to become the superuser 
 -the su/sudo commands can be used to run single 
  commands or whole sessions 
 

**su—Run a Shell with Substitute User/Group IDs**

 -the su command lets you use the shell as 
  another user: 

    $ su [-[l]] [user]

 -if the -l option is included it will run a 
  login shell 
 -if you just do su - with no user, it will log
  you in as root 
  
    $ su -

 -if you are going as root or another user, 
  in both cases it will ask for their password
 -use the exit command to go back to your  
  previous shell

    $ exit 
 
 -you can also execute a single command 
 
    $ su -c 'command'
 
 -it is important to put it into single quotes 
  because we dont want the expansion to mess up
 
**sudo—Execute a Command as Another User**
 -the sudo command lets you execute a command 
  as another user, and can be configured for your
  distro to be the super user. 
 -it can be configured to run only certain  
  commands as well

    $ sudo backup_script

 -you are then prompted for YOUR password, not
  the superuser's
 -sudo does NOT start a new shell, nor does it 
  start a new environment like su does 
 -meaning you do not need quotes with sudo 
 -privileges granted by sudo are different with 
  distros, so 
    
    $ sudo -l 
  
  to see what commands are allowed 


**ubuntu and sudo**
 -ubuntu doesn't let you operate as the root 
  account with su for security reasons, 
  so Ubuntu disables the login for the root by
  failing to set a password for it, and instead
  uses sudo for superuser privileges 
 -the "superuser" for ubuntu is the primary 
  account you created when you first booted the 
  machine, so you must be logged in as that 
  user to use sudo, 
 -unless you configure it otherwise 


**chown—Change File Owner and Group**

    $ chown [owner][:[group]] file...

 -the chown (change owner) command lets you
  change the owner and group owner of a file
 -it requires super user privileges, so in 
  ubuntu its: sudo chown  
 -here is a table with all the options: 

**Table 9-7: chown Argument Examples**
chown bob 
    Changes the ownership of the file from its 
    current owner to user bob. the group is 
    unchanged
chown bob:users 
    Changes the ownership of the file from its 
    current owner to user bob and changes the 
    file group owner to group users.
:admins 
    Changes the group owner to the group admins. 
    The file owner is unchanged.
bob: 
    Change the file owner from the current owner 
    to user bob and changes the group owner to 
    the login group of user bob.


 -in older versions of Unix, chown was only for 
  changing file, not group ownership, to do that
  you used to use the chrgrp

**Exercising Your Privileges**
 -lets say we want to create a shared music folder and have members of music able to 
  edit it
 -create a group using either the gui or by using the commands given in the interlude
 -then create a directory, in a shared folder: 
  
    $ sudo mkdir /usr/local/share/Music

 -this creates a directory with root permissions, so we need to change this: 

    [bill@linuxbox ~]$ sudo chown :music /usr/local/share/Music
    //makes it so root is still the owner of the file, but the group owner is music
    [bill@linuxbox ~]$ sudo chmod 775 /usr/local/share/Music
    //this sets the file to rwx rwx r-x (the others can execute since it's a dir)
    [bill@linuxbox ~]$ ls -ld /usr/local/share/Music
    drwxrwxr-x 2 root music 4096 2012-03-21 18:05 /usr/local/share/Music

 -this is fine, but now when each user makes a file or dir. in the music folder, 
  that file\dir will belong to them, not the group, so we need to add special 
  permissions 
 -we need to set the setgid bit on the directory: 

    [bill@linuxbox ~]$ sudo chmod g+s /usr/local/share/Music
    [bill@linuxbox ~]$ ls -ld /usr/local/share/Music
    drwxrwsr-x 2 root music 4096 2012-03-24 20:03 /usr/local/share/Music

 -remember the setgid bit makes it so that all files and dir. inside a directory
  have the same permsissions as the parent dir.
 -NOTE: make sure the umask is set correctly to 0002, we learn how to do this for 
  all sessions later in chapter 11
 

**Changing Your Password**
 -passwd [user] is how you change your password 
 -some distro of linux will enforce strong passwords that have to be a certain length
  and can't be too close to your old one (ubuntu doesn't seem to do this) 

/////////////////////////////////////////////////////////////////////////////////////
                                    CH10 PROCESSES 

 -modern systems use multitasking, which is when the CPU rapidly switches between 
  programs to give the illusion that it's doing more than one thing at a time 
 -linux kernel manages this through "processes" 


**How a Process Works**
 -on boot, the kernel initiates some of it's own processes and one of those is called 
  init, which in turn runs some init scripts found in /etc directory
 -many of these are daemon programs, which operate independent of the user interface 
  or logins
 -a process that launches another is a "parent process" and the "child process" is 
  what launched 
 -the kernel keeps track of all processes, and assigns them Process ID's (PIDs)
 -PIDs are assigned ascending, so init is always PID #1
 -processes also have owners, user IDs, memory assignments and more 

**Viewing Processes with ps**
 -$ ps is the most common command used to track processes: 

    [me@linuxbox ~]$ ps
    PID   TTY   TIME     CMD
    5198  pts/1 00:00:00 bash
    10129 pts/1 00:00:00 ps

 -here is the basic: 
    -PID = process ID
    -TTY = stands for "teletype" from ancient unix, and now refers to the controlling 
     terminal 
    -TIME = the CPU time consumed by the process 
    -CMD = the command in question. so from ps to firefox, every program has 1 or more
 -ps alone just shows the programs done by the current terminal, to see all processes:
  
    [me@linuxbox ~]$ ps x
    PID  TTY   STAT TIME  COMMAND
    2799 ?     Ssl  0:00  /usr/libexec/bonobo-activation-server –ac
    2820 ?     Sl   0:01  /usr/libexec/evolution-data-server-1.10 --
    //and many more... 

 -by adding the x option (note, no leading dash here) we see more info as well:
    STAT = the "state" of the program, check table for more info

**Table 10-1: Process States**  
    R 
      Running. The process is running or ready to run.
    S   
      Sleeping. The process is not running; rather, it is waiting for an event,
      such as a keystroke or network packet.
    D 
      Uninterruptible sleep. Process is waiting for I/O such as a disk drive.
    T 
      Stopped. Process has been instructed to stop (more on this later).
    Z 
      A defunct or “zombie” process. This is a child process that has
      terminated but has not been cleaned up by its parent.
    <   
      A high-priority process. It’s possible to grant more importance to a
      process, giving it more time on the CPU. This property of a process is
      called niceness. A process with high priority is said to be less nice
      because it’s taking more of the CPU’s time, which leaves less for
      everybody else.
    N 
      A low-priority process. A process with low priority (a nice process)
      will get processor time only after other processes with higher priority
      have been serviced.

 -sometimes the STAT may be followed by other characters, see the man page for more 
  info on what these mean for the processes
 -another popular option for ps is the aux (again, no leading dash), which emulates 
  a "BSD-style" behavior and shows all processes from all users: 

  [me@linuxbox ~]$ ps aux
  USER PID %CPU %MEM VSZ  RSS  TTY STAT START  TIME COMMAND
  root 1   0.0  0.0  2136 644  ?   Ss   Mar05  0:31 init
  root 2   0.0  0.0  0    0    ?   S<   Mar05  0:00 [kt]
  root 3   0.0  0.0  0    0    ?   S<   Mar05  0:00 [mi]
  root 4   0.0  0.0  0    0    ?   S<   Mar05  0:00 [ks]
  //and many more...

 -here are what all the terms mean in this emulated BSD style output: 

**Table 10-2: BSD-Style ps Column Headers**
  USER 
      User ID. This is the owner of the process.
  %CPU 
      CPU usage as a percent.
  %MEM 
      Memory usage as a percent.
  VSZ 
      Virtual memory size.
  RSS 
      Resident Set Size. The amount of physical memory (RAM) the process is 
      using in kilobytes.
  START 
      Time when the process started. For values over 24 hours, a date
      is used.


**Viewing Processes Dynamically with top**
 -ps is a static shot, to see dynamic version that updates at least every 3 seconds,
  use the top command: 

   [me@linuxbox ~]$ top
    top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00
    Tasks: 109 total, 1 running, 106 sleeping, 0 stopped, 2 zombie
    Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si
    Mem: 319496k total, 314860k used, 4636k free, 19392k buff
    Swap: 875500k total, 149128k used, 726372k free, 114676k cach
    
    PID   USER   PR   NI   VIRT   RES   SHR   S   %CPU  %MEM  TIME+      COMMAND
    6244  me     39   19   31752  3124  2188  S   6.3   1.0   16:24.42   trackerd
    11071 me     20   0    2304   1092  840   R   1.3   0.3   0:00.14    top
    6180  me     20   0    2700   1100  772   S   0.7   0.3   0:03.66    dbus-dae
    1     root   20   0    2976   528   476   S   0.0   0.2   0:03.14    init
    2     root   15   -5   0      0     0     S   0.0   0.0   0:00.00    kthreadd
    //and many more 

 -the top command has 2 parts, the system summary at the top, and the table of 
  processes sorted in order of descending CPU activity 
 -here are what the system summary means: 
  
**Table 10-3: top information fields**
ROW 1 
  top
    Name of the program.
  14:59:20 
    Current time of day.
  up 
    6:30 This is called uptime. It is the amount of time since
    the machine was last booted. In this example, the
    system has been up for 6½ hours.
  2 users 
    Two users are logged in.
  load average: 
    Load average refers to the number of processes
    that are waiting to run; that is, the number of processes
    that are in a runnable state and are sharing
    the CPU. Three values are shown, each for a different
    period of time. The first is the average for the
    last 60 seconds, the next the previous 5 minutes,
    and finally the previous 15 minutes. Values under
    1.0 indicate that the machine is not busy.
ROW 2
  Tasks: 
    This summarizes the number of processes and their
    various process states.
  0.7%us 
    0.7% of the CPU is being used for user processes.
    This means processes outside of the kernel itself.
  1.0%sy 
    1.0% of the CPU is being used for system (kernel) processes.
  0.0%ni 
    0.0% of the CPU is being used by nice (low-priority) processes.
  98.3%id 
    98.3% of the CPU is idle.
  0.0%wa 
    0.0% of the CPU is waiting for I/O.
ROW 4
  Mem: i
    Shows how physical RAM is being used.
ROW 5 
  Swap: 
    Shows how swap space (virtual memory) is being used.

 -use h for help, and q to quit
 -top is better than a gui task manager because it uses less resources 


**Controlling Processes**
 -now that we can monitor processes let's control them 
 -xlogo is a simple command that shows an x logo in a resizable window
 -to launch a program from the command line in linux, just type it into the 
  command line 
 -however, when you do this, notice there is no shell prompt, the shell is busy 
  running our program 


**Interrupting a Process**
 -interrup a process in a terminal by typing CTRL-C
 -interrupts "politely" tells a program to terminate
 -most programs respond to this, but not all 


**Putting a Process in the Background**
 -shells have foregrounds and backgrounds, to launch a program in the background, 
  use the &: 

    $ xlogo &
    [1] 28236
    $
 
 -those numbers are part of the shell feature "job control", that message tells us 
  the job number [1] and the PID 28236
 -use the jobs command to see all jobs in the shell currently going: 

    $ jobs
    [1]+ Running              xlogo &
 
 
**Returning a Process to the Foreground**
 -jobs in background are immune to keyboard input, so CTRL-C wont work
 -to bring it to the front use the fg command: 

    $ fg %1
    xlogo

 -this brings the process to the foreground and removes our prompt, it can now 
  be interrupted 


**Stopping (Pausing) a Process**
 -sometimes you want to pause a program so you can then get the prompt back and move 
  the program to the background
 -to stop (pause) a foreground program, use CTRL-Z, then use the bg command: 

    [me@linuxbox ~]$ xlogo
    //type CTRL-Z
    [1]+ Stopped xlogo
    [me@linuxbox ~]$
    [me@linuxbox ~]$ bg %1
    [1]+ xlogo &
    [me@linuxbox ~]$
 
 -the fg and bg commands both use the same syntax, %[jobspec]
 -if there is only one process running in the shell, you do not need the job number
 -NOTE: job numbers are static in the session, if you deleted job 1, job 2 doesn't 
  become job one
 -launching from command line is useful as some programs (like xlogo) aren't listed 
  in the window manager's memus, and when launched from the shell you can see 
  error messages that you might not get to otherwise 


**Signals**
 -the kill command is used to "kill" (terminate) programs

    [me@linuxbox ~]$ xlogo &
    [1] 28401
    [me@linuxbox ~]$ kill 28401
    [1]+ Terminated xlogo

 -you can also use the jobspec to terminate (eg kill %2)
 -the kill command sends signals, which are one of the ways the OS communicates with 
  the program
 -the other signals we know are CTRL-Z called TSTP (terminal stop) and CTRL-C 
  (interrupt), the kill command default to the TERM signal (ternimate)
 -programs listen for signals, which let them do things like save when they are told 
  to terminate


**Sending Signals to Processes with kill**
 -the most common syntax for kill: 

    $ kill [-signal] PID...
 
 -if no signal is given TERM (terminate) is the default. below are the signals:

**Table 10-4: Common Signals**
  1 HUP 
    Hang up. This is a vestige of the good old days
    when terminals were attached to remote computers
    with phone lines and modems. The signal is used
    to indicate to programs that the controlling terminal
    has “hung up.” The effect of this signal can
    be demonstrated by closing a terminal session.
    The foreground program running on the terminal
    will be sent the signal and will terminate.
    This signal is also used by many daemon
    programs to cause a reinitialization. This means
    that when a daemon is sent this signal, it will
    restart and reread its configuration file. The
    Apache web server is an example of a daemon
    that uses the HUP signal in this way.
  2 INT 
    Interrupt. Performs the same function as the CTRL-C
    key sent from the terminal. It will usually terminate
    a program.
  9 KILL 
    Kill. This signal is special. Whereas programs may
    choose to handle signals sent to them in different
    ways, including by ignoring them altogether, the
    KILL signal is never actually sent to the target
    program. Rather, the kernel immediately terminates
    the process. When a process is terminated in
    this manner, it is given no opportunity to “clean
    up” after itself or save its work. For this reason, the
    KILL signal should be used only as a last resort
    when other termination signals fail.
    15 TERM Terminate. This is the default signal sent by
    the kill command. If a program is still “alive”
    enough to receive signals, it will terminate.
  18 CONT 
    Continue. This will restore a process after a STOP
    signal.
  19 STOP 
    Stop. This signal causes a process to pause
    without terminating. Like the KILL signal, it is not
    sent to the target process, and thus it cannot be
    ignored.

 -so in context it goes: 

    [me@linuxbox ~]$ xlogo &
    [1] 13546
    [me@linuxbox ~]$ kill -1 13546
    [1]+ Hangup xlogo

 -you can use the signal numbers, name, or name and prefix SIG (signal): 

    [me@linuxbox ~]$ xlogo &
    [1] 13601
    [me@linuxbox ~]$ kill -INT 13601
    [1]+ Interrupt xlogo
    [me@linuxbox ~]$ xlogo &
    [1] 13608
    [me@linuxbox ~]$ kill -SIGINT 13608
    [1]+ Interrupt xlogo

 -while the 10.4 table signals are often used with kill, here are some other 
  common ones: 


**Table 10-5: Other Common Signals**
  3 QUIT  
    Quit.
  11 SEGV 
    Segmentation violation. This signal is sent if a
    program makes illegal use of memory; that is, it
    tried to write somewhere it was not allowed to.
  20 TSTP 
    Terminal stop. This is the signal sent by the terminal
    may choose to ignore it.
  28 WINCH 
    Window change. This is a signal sent by the system
    when a window changes size. Some programs,
    like top and less, will respond to this signal by
    redrawing themselves to fit the new window
    dimensions.

 -do $ kill -l to see a full list of signals used with kill

**Sending Signals to Multiple Processes with killall**
 -you can also kill programs by name with the killall command
 -killall will kill every instance of a program by name or name and user 
  but it's also useful to just kill a program you know the name of, but not 
  the PID, ie "killall firefox"
 -useful for scripting 

  $ killall [-u user] [-signal] program-name...

  [me@linuxbox ~]$ xlogo &
  [1] 18801
  [me@linuxbox ~]$ xlogo &
  [2] 18802
  [me@linuxbox ~]$ killall xlogo
  [1]- Terminated xlogo
  [2]+ Terminated xlogo

**More Process-Related Commands**
 -here are other common commands to monitor processes: 

**Table 10-6: Other Process-Related Commands**
  pstree 
    Outputs a process list arranged in a tree-like pattern showing
    the parent/child relationships between processes.
  vmstat 
    Outputs a snapshot of system resource usage including
    memory, swap, and disk I/O. To see a continuous display,
    follow the command with a time delay (in seconds) for updates
    (e.g., vmstat 5). Terminate the output with CTRL-C.
xload 
    A graphical program that draws a graph showing system load
    over time.
tload 
    Similar to the xload program, but draws the graph in the
    terminal. Terminate the output with CTRL-C.



/////////////////////////////////////////////////////////////////////
                      PART2 
/////////////////////////////////////////////////////////////////////
                    CH11 THE ENVIRONMENT 
 -the shell maintains info during our session called the environment
 -most programs used "configuration files' to store program settings 
  some will look to the environment
 

**what Is Stored in the Environment?**
 -shell stores two types of variables: environment variables and 
  shell variables. 
 -in bash, the two are almost the same 
 -shell variables are bits of data placed there by bash, and some 
  programatic things like aliases and shell functions, 
  environment variables are everything else
  

**t Is Stored in the Environment?**
 -to check the environment variables only, use the printenv command: 

    $ printenv | less

    KDE_MULTIHEAD=false
SSH_AGENT_PID=6666
HOSTNAME=linuxbox
GPG_AGENT_INFO=/tmp/gpg-PdOt7g/S.gpg-agent:6689:1
SHELL=/bin/bash
TERM=xterm
XDG_MENU_PREFIX=kde-
HISTSIZE=1000
XDG_SESSION_COOKIE=6d7b05c65846c3eaf3101b0046bd2b00-1208521990.996705-11770561
99
GTK2_RC_FILES=/etc/gtk-2.0/gtkrc:/home/me/.gtkrc-2.0:/home/me/.kde/share/confi
g/gtkrc-2.0
GTK_RC_FILES=/etc/gtk/gtkrc:/home/me/.gtkrc:/home/me/.kde/share/config/gtkrc
GS_LIB=/home/me/.fonts
WINDOWID=29360136
QTDIR=/usr/lib/qt-3.3
QTINC=/usr/lib/qt-3.3/include
KDE_FULL_SESSION=true
USER=me
LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33
;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe:

 -to see a single variable, just specify: 

    $ printenv USER
    me

 -to see both shell and environment variables, use the set command:

    $ set | less

 -set arranges variables alphabetically as well as any defined shell
  functions
 -you can also use echo to see variables, just use the $ sign: 

    $ echo $USER
    me

 -set and printenv do not show aliases, to see them, use the alias 
  command: 

    $ alias
    //all your aliases 

**Table 11-1: Environment Variables**
DISPLAY 
  The name of your display if you are running a graphical
  environment. Usually this is :0, meaning the first display
  generated by the X server.
EDITOR 
  The name of the program to be used for text editing.
SHELL 
  The name of your shell program.
HOME  
  The pathname of your home directory.
LANG 
  Defines the character set and collation order of your language.
OLD_PWD 
  The previous working directory.
PAGER 
  The name of the program to be used for paging output. This is
  often set to /usr/bin/less.
PATH  
  A colon-separated list of directories that are searched when you
  enter the name of an executable program. 
PS1 
  Prompt String 1. This defines the contents of your shell prompt.
  As we will later see, this can be extensively customized.
PWD 
  The current working directory.
TERM 
  The name of your terminal type. Unix-like systems support many
  terminal protocols; this variable sets the protocol to be used
  with your terminal emulator.
TZ
   Specifies your time zone. Most Unix-like systems maintain the
  computer’s internal clock in Coordinated Universal Time (UTC)
  and then display the local time by applying an offset specified
  by this variable.
USER 
  Your username.

 -not all distros have all variables listed, and set doesn't display
  all of them, sometimes you need to check just printenv
 

**How Is the Environment Established?**
 -when bash starts up it checks for "startup files" which tell it what 
  to do, there are various scripts to run depending on the type of 
  shell and what user is logged in

**Login and Non Login Shell**
 -login shells are typically ones where a user is prompted for a name 
  and a password, and non login shells are generally started in the gui


 -here are the login shell scripts
**Table 11-2: Startup Files for Login Shell Sessions
/etc/profile 
  A global configuration script that applies to all users.
~/.bash_profile 
  A user’s personal startup file. Can be used to extend or
  override settings in the global configuration script. 
~/.bash_login 
  If ~/.bash_profile is not found, bash attempts to read this
  script.
~/.profile 
  If neither ~/.bash_profile nor ~/.bash_login is found, bash
  attempts to read this file. This is the default in Debian-based
  distributions, such as Ubuntu.


 -here are the non login scripts:
**Table 11-3: Startup Files for Non-Login Shell Sessions**
/etc/bash.bashrc 
  A global configuration script that applies to all users.
~/.bashrc 
  A user’s personal startup file. Can be used to extend or
  override settings in the global configuration script.

 -non login shells do adopt some of their environment from a 
  parent process, ussually the login shell
 -ussually ~/.bashrc is the most important, since it affects the 
  regular users the most and some login set ups are configured to
  read it 


**What's in a startup script?**
 -here's an example of a ~/.bash_profile login script from CentOS-4
    # .bash_profile
    # Get the aliases and functions
  
    if [ -f ~/.bashrc ]; then
    . ~/.bashrc
    fi
  
    # User specific environment and startup programs
    PATH=$PATH:$HOME/bin
    export PATH

 -the lines that start with # are comments 
 -the fourth line down is called an "if compound statement" and checks 
  for the existence of a file, if the file exists, read it
 -the PATH variable is ussually set by /.profile script, here it is 
  is using expansion to say:
    the path variable = the current path variable + usrer's home/bin dir
    export the new path
 -this is a simple way of expanding a variables, like so: 

    $ foo="This is some"
    $ echo $foo
    this is some
    $ foo=$foo" text."
    //notice you have no concatenation operator, shell expansion
    //works as if you wrote it out right thereso  
    //so in that PATH example above, the : is just becuase PATH uses that
    //to separate directories, not for concatenation
    $ echo $foo
    this is some text


  -back the the startup script, that last line 

    export PATH

 -tells the shell that all children processes should use that variable
  as well


**Modifying the Environment**
 -generally, adding additional PATH dir. and environment variables goes 
  in ~/.bash_profile (or for ubuntu, ~/.profile) while all other aliases
  and changes go into your ~/.bashrc
 -admins can configure /etc/.profile and change things for all users, 
  but don't do that unless you really need to
 

**Text editors**
 -text are CLI or GUI based, and there are a ton
 -GNOME ships with gedit, KDE uses kedit, kwrite, kate
 -most common are nano, vi (vim) and emacs
 -fun fact: nano is meant to replace pico from the PINE email suite

 
**using a text editor**
 -you can call any text editor from the command line like: 

    $ editor file

 -if the named file doesnt exist, the text editor assumes you will want 
  to create it. the created file is made as long as you save your work
  once inside the editor
 -NOTE: it is good practice to ALWAYS create backup versions of 
  important files before you start editing them: 

    $ cp .bashrc .bashrc.bak // short for back up
    $ nano .bashrc
_____________________________________________________________________
    GNU nano 2.0.3                 File: .bashrc
    
    # .bashrc
    
    # Source global definitions
    if [ -f /etc/bashrc ]; then
    . /etc/bashrc
    fi
    
    # User specific aliases and functions

                        [ Read 8 lines ]
    ^G Get Help ^O WriteOut^R Read Fil ^Y Prev Pag ^K Cut Text ^C Cur Pos
    ^X Exit     ^J Justify ^W Where Is ^V Next Pag ^U UnCut Te ^T To Spel

 -this is how nano text editor looks
 -it has the file name and nano version at the top, the file itself 
  in the middle, and the commands at the bottom
 -the ^ is short for CTRL 
 -CTRL-X is exit, CTRL-O is save (when you CTRLX it will ask you to save)
 

**Activating Our Changes**
 -if you alter startup files they wont take effect until the next time you
  start up, OR you can use the source command: 

    $ source ~/.bashrc 

 -note: you mistakenly thought you had to use source IN start up scripts,
  but you can just reverence the script with ./scriptname as we saw above


**Commentin is so importanth**
 -commenting is used so you will know at a later date what the hell you
  were thinking and so that other coders can figure it out as well
 -theres also the technique of "uncommenting" which is when you leave 
  working parts of your code commented out/uncommented so that people 
  can configure the script hopw they want 
 -ubuntu does this with aliases in its bashrc so that users can 
  select which preconfigured choices will have an effect


/////////////////////////////////////////////////////////////////////
              CH12 A GENTLE INTRODUCTION TO VI
 -vi is great for lightweight speed and is always available and gives
  you street cred with other users 
 -inced it's pronounced vee eye and vim is vim 


**A little background**
 -before "visual editors" computers used "line editors" where you 
  would have to type in the line number then make edits, once 
  video screen replaced printers, visual editing became possible
 -vi actually incorporates the line editor program ex as we will see
  later

**NOTE**
 -honestly, this chapter is great but you already have the main meat 
  in your vim notes, so below are any random things you didn't catch
  from before:

  SHIFT6 (^) moves you to first non whitespace character on the line
  funfact: hjkl are movement keys becuase when vi was written, 
    arrow keys were not on standard on keyboards
  d20G  delete from From the current line to the 20th line of the file
  Joining lines 
    use J to join lines by placing your cursor at the end of one line
    and then hit J to merge them with a space in between (uppercase j)

  explaining search and replace syntax: 
  Table12-5: An Example of Global Search-and-Replace Syntax
  : The colon character starts an ex command.
  % Specifies the range of lines for the operation. % is a shortcut
    meaning from the first line to the last line. Alternatively, the
    range could have been specified 1,5 (because our file is five
    lines long), or 1,$ , which means “from line 1 to the last line in
    the file.” If the range of lines is omitted, the operation is
    performed only on the current line.
  s Specifies the operation—in this case, substitution (search and
    replace).
  /Line/line/ The search pattern and the replacement text.
  g This means global, in the sense that the substitution is per-
    formed on every instance of the search string in each line.
    If g is omitted, only the first instance of the search string on
    each line is replaced.  
  c  asks for confirmation with each replacement

  when asking for confirmation, it lists the following options each
  time. here are what they mean:

    y -Perform the substitution.
    n -Skip this instance of the pattern.
    a -Perform the substitution on this and all subsequent
      instances of the pattern.
    q or ESC  -Quit substituting.
    l -Perform this substitution and then quit. Short for last.
    CTRL -E, CTRL -Y -Scroll down and scroll up, respectively. Useful
       for viewing the context of the proposed substitution.



/////////////////////////////////////////////////////////////////////
                CH13 CUSTOMIZING THE PROMPT
**Anatomy of a Prompt**
 -the promt value is stored in the variable PS1 (prompt string 1)
  
    $ echo $PS1
    [\u@\h \W]\$

 -here are the escape codes common for shell prompts:

**Table 13-1: Escape Codes Used in Shell Prompts
  \a ASCII bell. This makes the computer beep when it is
    encountered.
  \d Current date in day, month, date format; for example,
    “Mon May 26”
  \h Hostname of the local machine minus the trailing domain name
  \H Full hostname
  \j Number of jobs running in the current shell session
  \l Name of the current terminal device
  \n A newline character
  \r A carriage return
  \s Name of the shell program
  \t Current time in 24-hour, hours:minutes:seconds format
  \T Current time in 12-hour format
  \@ Current time in 12-hour, am/pm format
  \A Current time in 24-hour, hours:minutes format
  \u Username of the current user
  \v Version number of the shell
  \V Version and release numbers of the shell
  \w Name of the current working directory
  \W Last part of the current working directory name
  \! History number of the current command
  \# Number of commands entered during this shell session
  \$ This displays a “$” character unless you have superuser
    privileges. In that case, it displays a “#” instead.
  \[ This signals the start of a series of one or more non-printing
    characters. It is used to embed non-printing control characters
    that manipulate the terminal emulator in some way, such as
    moving the cursor or changing text colors.
  \] This signals the end of a non-printing character sequence.

 -before messing with PS1, save the old value in your shell: 

    $ PS1_old=$PS1

 -now we can always reset to our original value 

    $ PS1=$PS1_old

 -setting new a new PS1 value is easy: 

    $ PS1="\u@\w \$ "
    //remember to leave a space at the end so new entries arent right
    //against the prompt itself

**Adding color**
Table13-2: Escape Sequences Used to Set Text Colors
Sequence Text Color
\033[0;30m Black
\033[0;31m Red
\033[0;32m Green
\033[0;33m Brown
\033[0;34m Blue
\033[0;35m Purple
\033[0;36m Cyan
\033[0;37m Light Gray
\033[1;30m Dark Gray
\033[1;31m Light Red
\033[1;32m Light Green
\033[1;33m Yellow
\033[1;34m Light Blue
\033[1;35m Light Purple
\033[1;36m Light Cyan
\033[1;37m White

PS1="\[\033[0;31m\]<\u@\h \W>\$ "
//this would give a red prompt, but so would the commands
PS1="\[\033[0;31m\]<\u@\h \W>\$\[\033[0m\] "
//that 0m resets the color 

**background color**
Table 13-3: Escape Sequences Used to Set Background Color
  \033[0;40m Black
  \033[0;41m Red
  \033[0;42m Green
  \033[0;43m Brown
  \033[0;44m Blue
  \033[0;45m Purple
  \033[0;46m Cyan
  \033[0;47m Light Gray

 -this gives you a red background for example:

    $ PS1="\[\033[0;41m\]<\u@\h \W>\$\[\033[0m\] "

 -NOTE: Besides the normal (0;) and bold (1;) character attributes, 
  text may also be given under- score (4;), blinking (5;), and 
  inverse (7;) attributes. In the interests of good taste, many
  terminal emulators refuse to honor the blinking attribute. 
 -\033[1;41m\] would be bold text with red outline, for example 

**moving the cursor**
\033[l;cH Move the cursor to line l and column c .
\033[nA   Move the cursor up n lines.
\033[nB   Move the cursor down n lines.
\033[nC   Move the cursor forward n characters.
\033[nD   Move the cursor backward n characters.
\033[2J   Clear the screen and move the cursor to the upper-left corner
  (line 0, column 0).
\033[K    Clear from the cursor position to the end of the current line.
\033[s    Store the current cursor position.
\033[u    Recall the stored cursor position.

 -to save your new PS1 value and make it permanent, add it into your 
  bashrc file 


////////////////////////P/////////////////////////////////////////////
                        PART3
            COMMON TASKS AND ESSENTIAL TOOLS    
/////////////////////////////////////////////////////////////////////
              CH14 PACKAGE MANAGEMENT
 -one of the big differences in linux distros is how they deal with 
  packages
 -packages are a collection of files that are necessary for a program
  to run
   -this is how virtually all linux programs are recieved, which is 
    better than how it used to be, when people would have to download
    and compile programs from source code
   -which is still technically An option 
 -there are two main package file types:
    .deb -for Debian, Ubuntu, Xandros, Linspire
    .rpm -for Fedora, CentOS, Red Hat Enterprise Linux, openSUSE,
      Mandriva, PCLinuxOS
    -there are other types for distros like gentoo and slackware,
     but these are the main ones 

**how the package system works**
 -unlike mac and pc, which use installation wizards, linux software
  is found online
 -a package manager takes the source files and makes them easier to 
  load, and then gives them to sent to a repository
 -repositores often have several different versions of the repositories
  for the different stages of software development
 -sometimes packages will have dependencies on shared libraries, things 
  like programs that handle i/o 
   -if this is the case, most packages will have dependency resolution
    that deals with this problem and installs everything needed


**high and low level tools**
 -low-level tools that handle tasks such as installing 
  and removing package files, 
 -and high-level tools that perform metadata searching and 
  dependency resolution.
 -here are the high and low level programs for debian and red hat 
  flavors of linux
                             low          high 
Debian style                 dpkg       apt-get , aptitude
Fedora, Red Hat
Enterprise Linux, CentOSi    rpm        yum

 -note that low level tools also let you create packages, that's just
  not in this book

 -NOTE from here on out package_name refers to the actual name of the
  package, while package_file refers to the actual file

**finding packages**
 -By using the high-level tools to search repository metadata, 
  one can locate a package based on its name or description

     deb    apt-get update
            apt-cache search search_string

     hat    yum search search_string

 so searching for vim is:
 
   apt-cache search vim // after updating for best results

**Installing a Package from a Repository**
 -High-level tools permit a package to be downloaded from a 
  repository and installed with full dependency resolution 

    Style          Command(s)
    Debian         apt-get update
                   apt-get install package_name

    Red Hat        yum install package_name

 -so installing vim-gtk (eg for clipboard access) :

    sudo apt-get install vim


 **nstalling a Package from a Package File**
 -If a package file has been downloaded from a source other than 
  a repository, it can be installed directly (though without 
  dependency resolution) using a low-level tool 

    Style            Command
    Debian           dpkg --install package_file
    Red Hat          rpm -i package_file 

 -so if you downloaded a package file from the internet:

    dpkg --install ~/Downloads/emacs-22.1-7.fc7-i386.deb 
   
 -
/////////////////////////////////////////////////////////////////////
VIEWING PDFS IN TERMINAL 
 -the fbi program is used for viewing images, but it has a sister 
  program called fbgs, which lets you view pdf
 -for the pi screen, you need to view at -xxl resolution, which is
  150 dpi
 -so this is the command:

    $ fbgs -xxl thing.pdf
    // to view images its just fbi file.png or fbi fil.jpg

