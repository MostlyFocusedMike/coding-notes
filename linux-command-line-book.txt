/////////////////////////////////////////////////
WIDTH OF MINI PI SCREEN

/////////////////////////////////////////////////
        CH1- WHAT IS THE SHELL?
 -When we talk about the command line we are 
  really referring to the "shell" which is a 
  program command that takes keyboard vommands 
  and pass them to the OS to carry out.
 -Almost all linux distrobutions support the 
  shell program "bash", which is provided by the
  GNU project
 -Bash stands for "bourne again shell" since
  it replaces the unix shell program "sh" by
  Steve bourne

**terminal emulators**
 -when using a gui, you need a "terminal emulator
  to interact with the shell.
  -KDE uses "konsole" and GNOME uses "gnome-
   terminal" (likely just labeled "terminal")
 -there are many types to choose from


**your first keystrokes**
 -the input prompt in a terminal is called a 
  shell prompt
 -usually its your username, machine name, and
  current working directory, but it can be edited

    mike@linux-machine ~$ 

 -if the last character is a # not $,
  the terminal has "superuser" priveleges" so
  you have administrator priveleges


**command history**
 -press the up arrow to see the previous command 
  entered. most linux distros save the last 500
  commands entered by default
 -use up and down arrows to navigate


**cursor movement**
 -use the arrow left and right keys to move along
  and edit commands
 -you can use the mouse with the terminal 
  emulator, the X window system events supports
  a quick copy paste mechanic. If you left click
  and drag over words, X copies them into a 
  buffer. click down with the middle mouse button
  to paste
 -ctl c and ctrl v don't work to copy and paste
  in some terminals
 -in ubuntu you can use shift ctrl c and v 
 -your GUI probably has a "focus policy" set to
  "click to focus" to match Windows, but X can
  set it to "focus follows mouse" which allows 
  you to mouse over a program without clicking 
  to add input, and it will come to the front 
  only if you click it
 -find this setting in the config program 
  for your window manager.

**try some simple commands
 -$ cal   
  this displays a calendar of the month
 -$ date
  this displays the current time and date
 -$df
  shows free space on disk drives
 -$free 
  shows free memory

**ending a terminal session**
 -$exit
  closes the terminal emulator

**the console behind the curtain**
 -there are "virtual terminals" running behind 
  the gui scenes in most linux distros
 -these can be accessed by hitting ctrl alt F1 
  through F6
 -to switch between them, usealt f1-f6 
 -to get back to gui, use alt f7
 -NOTE: mini pi seems not to be able to switch
  from gui, but can switch between f1, 3, and 5
  like most systems  


/////////////////////////////////////////////////
                CH2 NAVIGATION

**understanding the filesystem tree**
 -unix-like systems like linux use a 
  heirarchical directory structure, meaning 
  the "root" directory holds all subdirectories 
 -the root file is just /, as if you wrote root/
 -unlike Windows, which has separate file 
  systems for each storage device, unix and linux
  have all drives on one tree, with the admin
  deciding where on the tree devices and drives
  are "mounted" (stored)
 

**the current working directory**
 -the folder you are in is your "current working
  directory" 
 -$pwd 
  this Prints Working Directory you are in
 -when you first log in to a terminal, you are
  in the home directory (~ is the shorthand for
  /home/[username here]) 
 -each user is given their own home directory 
  and it is the only place they can write files
  without admin priveleges


**listing the contents of a directory**
 -$ls
  lists contents of a directory, more on this 
  in ch3
 

**changing current working directory (cwd)**
 -$cd directory-name
  this changes working directory to new 
  specified directory 
 -the shell prompt will change to reflect your
  new cwd (unless you took it off default)
 -can use either absolute or relative pathnames 
  to move:
 *absolute*:
 -the file location in relation to the root
    
    /home/pi/Desktop/test.txt
 
 *relative*:
 -the relative pathname of a file is the location
  in relation to your cwd
 -there are two symbols you can use with 
  relative pathnames . and ..
 -the . symbol refers to your cwd and the ..
  symbol refers to your cwd's parent directory
 
  cd ./file (file in cwd)
  cd ../file (file in the parent of cwd
 
 -note ./ is almost always omited, if no 
  absolute pathname is given, cwd is implied
 -you can use multiple .. at once 
 
    cd ../../file/goal

 -that takes you up two files etc.

**facts about filenames**
 -if there's a . in front of a file name, it is 
  hidden. you need to do $ls -a to see them
 -this is done for config and other files, 
  we will do more of this later
 -filenames in linux are case sensitive
 -limit punctuation in filenames to -, _, and .
 -do not use spaces, even though they are 
  technically allowed
 -file extensions don't technically matter either
 you can use any extension you want to name, 
  since programs parse files, not linux itself
 -so a file named "thing" works just as well as
  "thing.txt" as a name


/////////////////////////////////////////////////
        CH3 EXPLORING THE SYSTEM 

**more fun with ls**
 -$ ls 
  shows the contnts of your cwd 
 -$ ls Desktop/folder
  use an argument of a folder name to list out 
  that folders contents without moving your cwd
 -$ ls Desktop/folder Desktop/folder2
  separate folders with spaces to see multiple
  contents   


**options and arguments**
 -you can alter the effects of commands with 
  options and arguments: 

    $ command -option arguments

 -options alter what the command does and the 
  arguments affect what the command acts on
 -options can be case sensitive, so watch out
 -most options are a dash followed by a letter,
  but there are "long options" which are two 
  dashes followed by words 
 
    ls -a // ls --all 

 -the above options do the same thing 
 -short options can be strung together, just use
  a single dash, then multiple short options: 

    ls -alt // the -a, -l, and -t combine

 -short and long options can be used together if
  you want: 

    ls -alt --reverse 


**common ls options**
  -a, --all
  lists all files, even those that are hidden

  -d, --directory 
  ls normally shows you info on files in a dir, 
  but using -d with -l, you can get info on the 
  directory itself (like permissions and links)

  -F, --classify
  append an indecator character to the end of 
  file names (so directories get a / at the end)

  -h, --human-readable
  list file sizes in things like mb and k instead
  of raw bytes
  
  -l 
  display long format (this gives permeisions,  
  file sizes, owners and more, v useful)

  -r, --reverse 
  display results in reverse order, ls normally
  displays files in ascending alphanumeric order
  unless sorted otherwise

  -S
  sort results by file size

  -t 
  sort by when the last modification was, more 
  recent mods at the top


**a longer look at long format**

drw-r--r--  1 root root  6472 Sep 15 14:04 test
1           2 3    4     5    6            7

 -see below for what each field means 

  1
  Access rights to the file, the first character
  says what type of file it is, a - means a 
  regular file, a d is a directory. the next 3 
  are access rights for the files owner, the 
  next 3 are for members of the files group,
  the last three are everyone else. more in ch9

  2 number of hard links to file 

  3 user name of files owner

  4 name of group that owns the file 

  5 size of file in bytes 

  6 date of the files last modification

  7 name of the file 


**determining a files type with file**
 -since filenames are not required to determine 
  an actual file's filetype (ie a .jpg file might
  not actually containg a JPG file), you can 
  double check with the $file command: 

    $ file picture.jpg
    //picture.jpg: JPEG image data, JFIF standard 1.01

  -the file to analyze is an argument for the 
  command


**viewing file contents with LESS**
 -the less command helps you view text files 
 -text files are just one to one mappings of  
  characters to numbers (each char. is a byte)
 -ASCII and unicode are common text types 
 -the less command takes the file to read as 
  an argument: 
 
    $ less /etc/passwd 

 -less is a play on words, since the old unix 
  program was called "more", both programs are 
  examples of "pager" programs 
**less commands**

  PAGE UP key, b
  back one page 

  PAGE DOWN key, SPACE key
  down one page

  UP ARROW, DOWN ARROW  
  up one line, down one line 
  (there is no cursor, its jsut a page view)

  G, g 
  move to end of file, move to sart of file
  
  /characters 
  search for selected characters 
  n
  go to next character set match
  
  h
  display help screen
 
  q
  quit less 

  -notice the similar commands to vi 


**a guided tour**
 -most linux systems are similar and try to 
  conform to the "linux filesystem heirarchy 
  standard" 
 -below are some brief descriptions of the dirs:

 /
  the root dir, where everything is stored 

 /bin
  contains binaries (programs) that must be 
  present for system to boot 

 /boot 
  comtains the linux kernel, initial RAM disk 
  image, and boot loader 

 /dev 
  linux's philosophy of "everything is a file"
  applies to devices, and here is where the 
  kernel maintains a list of all devices it 
  understands 

 /etc 
  contains all system wide config files, and a
  collection of shell scrips that run at boot

 /home 
  each user gets a dir in /home, and here is 
  where they can write files without admin 
  priveleges. this is a safety feature 

 /lib
  contains shared libraries used by core system
  programs 

 /lost+found 
  used in the case of system corruption events 

 /media 
  on modern linux distros, this contains all 
  mountable devices like CDs and USBs that are 
  mounted automaticaly at insertion 
 
 /mnt 
  on older systems, mountable devices are here

 /opt
  used to install "optional" or commercial 
  hardware 

 /proc
  this is a weird dir, it isn't real, it's 
  virtual and maintained by the linux kernel.
  files are readable and gives a view of the 
  the kernel

 /root 
  home directory for the root account 

 /sbin
  contains "system" binaries, these are programs
  that perfom vital tasks reserved for the super
  user

 /tmp
  used for programs that create temporary files,
  some distros clear this each time on boot 

 /usr
  contains all programs and support files used 
  by regular users

 /usr/bin 
  contains executable programs installed by your
  linux distro, can contain 1000s of programs

 /usr/lib
  shared libraries for /usr/bin

 /usr/local 
  where programs that are not included with your
  distro, but indended for system-wide use are 
  stored. it's empty until admin puts stuff here

 /usr/sbin
  contains more sysadmin programs 

 /usr/share
  contains all shared data used by /usr/bin 
  programs like icons and defualt config files,
  background imgs etc etc

 /usr/share/doc
  the documentation for all /usr packages

 /var
  unlike most static directories, this is where
  variable changing data goes, like email and 
  databases

 /var/log
  log files, need to be a superuser to monitor 
  them


**symbolic links**
 -more later, but basically these are like 
  shortcuts that reference files
 -so if you need to referece a file that keeps 
  getting updated, instead of changing all files
  that reference that file with each update, 
  use a symbolic link, then reference that 
 -this means with each update, you just need 
  to change the symbolic link's destinations 

    file > symbolic link foo > mainfile1.0 

      Add updated version of file:

    file > symbolic link foo > mainfile1.1
                              mainfile1.0
 
 -this also lets you keep older versions for 
  easy rollback in case the new version has bugs
 -hard links are similar but more clunky, more 
  on these in next chapter 


/////////////////////////////////////////////////
  CH4 MANIPULATING FILES AND DIRECTORIES

**wildcards*** 
 -wildcards are special characters that help you 
  select files 
 -using wildcards is known as "globbing"

 *table 4-1 wildcards*
  * = any characters 
  ? = any single character
  [characters] = any characters in set characters
    NOTE: these are not strings, treat them as 
    arrays for finding a single char. in a set
  [!characters] = any NOT in set characters 
  [0-9] = any integer 0 through 9
  [[:class:]] = any char. in a specified class

 *table 4-2 commonly used character classes
  [:alnum:] = any alphanumerica character char.
  [:alpha:] = any alphabetic character
  [:digit:] = any numeral 
  [:lower:] = any lowercase letter
  [:upper:] = any uppercase letter

 -here are some examples: 
  * = all files 
  g* = any file starting with g 
  b* = any .txt file starting with b
  Data??? = files beginning with data and ending 
            with any 3 characters 
  [abc]* = files beginning with a, b, or c
  BACKUP.[0-9][0-9] = beggining with BACKUP 
                      followed by . then any 2 
                      digits
  [[:upper:]]* = any file starting with uppercase
                 letter
  [![:digit:]]* = files not starting with a digit
  *[[:lower:]123] = files ending with a lower
                    case letter OR the numerals 
                    1, 2, or 3

 -NOTE: in unix, you may come across [A-Z] [a-z]
  which work in older linux, but have dif results
  in modern. use the upper and lower classes 
  instead 
 -in a lot of linux distros, wildcards work in 
  gui searches too 


**mkdir -create directories**
 -$ mkdir new1
  the mkdir command creates a new directory
 -$ mkdir new1 new2 new3...
  make multiple at once by giving more than 
  one dir. name 


**cp -copy files and directories**
 -cp can be used in two main ways: copying 
  individual files, or copying files into 
  directories: 
 -$ cp item1 item2 
  this copies item1 to a new file called item2,
  if item2 already exists it gets overwritten
 -$ cp item1 item2 directory1
  this copies as many items into a new directory
 
 *cp options* //just a few of them
  -a, --archive 
    copy files and dir. with all their attributes
    including ownerships and permissions. the 
    default is to copy with the own. and perms.
    of user performing cp
  -i, --interactive
    before overwriting an existing file, 
    ask permission, default is to do it silently
    (as in not ask for permission)
  -r, --recursice
    recursively copy directories and their 
    contents. this or -a is required when 
    copying dir.
  -u, --update 
    when copying files from one directory to 
    another, only add the files that either 
    exist or are newer versions 
  -v, --verbose 
    display info messages as it does stuff
    these are not confirmations, just messages 
    that alert you to what step of the 
    process you are in

  *cp examples*
  cp file1 file2
    copies file, if fil2 exists it's overwritten
  cp -i file1 file2 
    if file2 exists, it asks for confirm 
    of overwrite 
  cp file1 file2 dir1
    copy files to directory
  cp dir1/* dir2
    use a wildcard to copy each file from 
    dir1 into dir2 
  cp -r dir1/ dir2
    same effect as above
  cp -r dir1 dir2
    copies the directory and its files (not just
    the loose files) into dir2. if dir2 does not
    exist, then it is created, and the loose 
    files inside dir1 will be in dir2 (without 
    being contained in dir1)
  cp /home/file1 . 
    copy file from another dir. into your cwd
    (use -r if it's a directory your copying)

**mv -move and rename files**
 -use mv to move and rename files:
 -$ mv item1 item2
  now item1 is called item2, if item2 exists it 
  is overwritten by item1. either way, item1 is 
  no longer a thing 
 -$ mv item1 dir1
  now item1 is in dir1 instead of where it was 
 *mv options*
  -i, --interactive
    same thing as cp's version
  -u, --update
    when moving files to new dir, it only moves 
    files that dont exist or are newer than the 
    dir's version
  -v, --verbose 
    same thing as usual 
  NOTE: you do not need to use -r ever with mv, 
    since it is basically designed to work with
    directories 

 *mv examples*
    mv file1 file2
      renames/overwittes file1 to be file2 (this
      works on files and directories)
    mv -i file1 file2
      if file2 exists, must confirm overwrite
    mv file1 file2 dir1
      move files to dir1 (any number of files)
    mv dir1 dir2
      move dir1 into dir2, if dir2 does not 
      exist, you have to make it first, otherwise
      this will just rename dir1 to dir2


**rm -remove files and directories**
 -$ rm item1 item2 ite...
  this permanently deletes the file 
 -BE FUCKING CAREFUL rm is instant and permanent
  if you are using wildcards, test it with ls 
  first to see what files you are deleting since:
  
    $ rm *.html
    $ rm * .html
  
  the second one will accidentally delete every
  file in your cwd then complain that there is 
  no file called ".html" to delete

 *rm options*
  -i, -interactive 
    same as usual
  -r, --recursive 
    needed for directories, same as usual
  -f, --force
    ignore nonexistent files and do not prompt
    this overrides the -i option
  -v, --verbose 
    display messages as usual 

 *rm examples*
  rm file1
    removes file
  rm -i file1
    asks for confirm before deletion
  rm -r file1 dir1 
    -r lets you delete directories 
  rm -rf file1 dir1
    same as above, but now if one of those 
    files doesn't exist, rm will continue 
    silently (otherwise it sends a little 
    warning message about the error even though
    both styles delete any real files they find)
  

**ln -create links**
 -create either hard of symbolic links with ln:
 -$ ln file link //hard link
 -$ ln -s file-or-dir link //symbolic links
  // ln test.txt hard //hard is the name of link
  // ln -s tip.txt sym //sym is the name of link
 -hard links are the original way to make links
  in unix. A link is just a new directory entry
  for a file. So instead of copying a file and 
  all it's space, a link is the same file that 
  can now be accessed from more than one  
  location on your computer
 -hard links can't reference a directory and they
  cant reference a file outside their disk 
  partition as the link itself 
 -links of both types can't have the same name 
  as a pre existing file or link. to overwrite
  a file/link to become a new link, you need to 
  use the -f (--force) option. 
 -symbolic links are the new way to make links 
  they can reference directories now 
 -another difference between symbolic and hard
  links is how they treat the deletion of the 
  file they link to: 
    -hard links literally ARE the file, so 
     the original file contents will not be 
     removed until all hard links are removed
    -symbolic links are just pointers, so if the 
     original file gets deleted, the link is 
     said to be broken and will come up as an 
     error (ls will ussually display them in 
     different colors once broken)
 -the links will act like what they are linking
  to, so if you link a file, you can edit the
  file or the link and both change. If the 
  symbolic link is to a directory, you can cd 
  into the dir. and it will contain the same 
  files as the original 
 
**telling links apart from sources**
 -symbolic links are obvious, when you ls -l, 
  they have an arrow from the link to the source
  file
 -hard links are harder, they don't look any 
  different from a regular file, to spot a 
  hard link, use ls -i, that -i shows each 
  file's "inode" (often used with -l option) 
 -to think about it in another way, all files 
  have 2 parts, a data part which holds the files
  content and a name part, which hold the file's 
  name and meta data. when you create a hard link
  your creating an additional name part that 
  refers to the same content
 -an inode is a chain of disk blocks that the 
  system assigns to it 
 -to find all links to a file, search for the 
  inode: 

    $ find ~/ -xdev -inum [inode num here]

**creating symlinks with the gui**
 -you can make symlinks in linux guis
 -usually there will be an option in the drop
  down menu when you right click an item, in 
  GNOME you hold ctrl+shift while dragging 
 -ubuntu, ctrl + drag + shift and then drop the
  now symbolic link where you want it (ctl + drag
   is how to make a copy of a file in the gui)



/////////////////////////////////////////////////
        CH5 WORKING WITH COMMANDS 
**what exactly are commands**
 -they are one of 4 things:
  -an executable program:
   like the files we saw in /usr/bin, they are 
   either "compiled binaries" written in C, c++
   or programs written in scripted languages like
   python, perl, ruby etc
  -a command built into the shell itself:
   bash supports a bunch of built in commands
   called "shell builtins" cd is this 
  -a shell function:
   "shell functions" are mini shell scripts built
   right into the environment
  -an alias 
   "alias" is a command that we configured 
   ourselves


**identifying Commands**
 -use $ type to figure out which of the 4 types 
  a command is: 
  
  $ type ls
  ls is /bin/ls
  $ type cd
  cd is a shell builtin
  $ type ll
  ll is aliased to 'ls -alt'

 -we can see some exampls, ls and cd, though they
  look similar, are actually different types 
 

**which -display an executables location
 -sometimes more than one version of an 
  executable is on a system, so to know the
  exact location of the exectuable use which: 

    $ which ls
    /bin/ls

 -only works on executables, but on macs, it 
  might work on other types of commands as well
  on linux it will give an error or no response


**Getting a commands documentation**
 -bash has help pages for each of the shell 
  builtins 

    $ help cd 
    //a bunch of stuff 

 -NOTE: when square brackets appear, they show 
  optional items, the | indicates mutally 
  exclusive terms 
 
  [-L|-D] [dir] 
 
 -the above means either L or D, then dir

 -for executable programs, use --help 

  $ mkdir --help 
  //bunch of stuff 

 -some programs dont support --help, but if you
  try --help, most cases the error message will 
  list all the options you'd need anyway


**man -display a programs manual page**
 -use: 

  $ man ls 
  $ man 5 ls

 -the first one opens up the full man page for 
  the command, the second opens only up one 
  section. the 8 possible section are below. 
  Not every command has every one of the sections
 -note: man stands for manual 

  1 user commands
  2 proframming interface for kernal system calls
  3 programming interface for C library
  4 special files for device nodes and drivers
  5 file formats
  6 games and extra fun stuff
  7 miscellaneous
  8 system admin commands 


**apropos -display approtiate commands**
 -search the man pages for a word, very crude but
  it can come up with relevant commands 

  $ apropos web
  cheese (1)  -details about program
  firefox(1)  -details about program
  //more programs 

 -the first field is the command, the second is
  the section the word comes up in first 
 -NOTE $ man -k  does the same thing as apropos


**whatis -display a brief description**
 -get a brief description of command: 

    $ whatis ls 


**info -display program's info entry**
 -the GNU project has an alternative to man pages
  called "info pages" and you read them with the 
  info program
 -the info pages are called info files, with 
  tree structures and each 'node' contains a 
  single topic. 
 -the notes are hyperlinked like webpages 
  
    $ info ls 

 -here are the info commands:
  ?   -display command help
  PAGE UP or BACKSPACE
    display previous page
  PAGE DOWN or SPACEBAR
    display next page
  n
    Next -display next node
  p
    Previous -diplay previous node
  u
    up- display parent node 
  ENTER
    follow hyperlink under cursor
  q
    quit 


**README and other program documentation**
 -most documentation is in /usr/share/doc
 -most are plaintext, so you can be viewed with 
  less
 -some are .html so view them as with browsers
 -some are .gz files, which have been compressed
  with the gzip compression, which you view with
  the zless program, which views compressed files
  

**Creating your own commands with alias**
 -it is possible to put more than one command
  on a line: 

    $ cd ..; ls; cd -

 -simply separate each command with a semicolon
  and a space 
 -alias lets you turn a sequence of commands or 
  a long command into a short cut that you can 
  type instead 
 -before making an alias, use type to check
  
  $ type test
  test is a shell builtin
  $type foo
  bash: type: foo: not found 

 -so like, test would be bad since it's taken, 
  but foo would be fine
 -you make a foo like this: 

    alias foo="cd /usr; ls; cd -"
    alias name="actual command in quotes"

 -you can now just type foo to get those 3 ones 
 -if you use the type command on foo, now it says
  
    $ type foo
    foo is aliased to 'cd /usr; ls; cd -'

 -you can also use an alias to override a command
  that does exist, if you want.
 -to see all aliases set up in your environment,
  just type alias into the command line 

    $ alias 
