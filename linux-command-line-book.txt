/////////////////////////////////////////////////
WIDTH OF MINI PI SCREEN

/////////////////////////////////////////////////
        CH. 1- WHAT IS THE SHELL?
 -When we talk about the command line we are 
  really referring to the "shell" which is a 
  program command that takes keyboard vommands 
  and pass them to the OS to carry out.
 -Almost all linux distrobutions support the 
  shell program "bash", which is provided by the
  GNU project
 -Bash stands for "bourne again shell" since
  it replaces the unix shell program "sh" by
  Steve bourne

**terminal emulators**
 -when using a gui, you need a "terminal emulator
  to interact with the shell.
  -KDE uses "konsole" and GNOME uses "gnome-
   terminal" (likely just labeled "terminal")
 -there are many types to choose from


**your first keystrokes**
 -the input prompt in a terminal is called a 
  shell prompt
 -usually its your username, machine name, and
  current working directory, but it can be edited

    mike@linux-machine ~$ 

 -if the last character is a # not $,
  the terminal has "superuser" priveleges" so
  you have administrator priveleges


**command history**
 -press the up arrow to see the previous command 
  entered. most linux distros save the last 500
  commands entered by default
 -use up and down arrows to navigate


**cursor movement**
 -use the arrow left and right keys to move along
  and edit commands
 -you can use the mouse with the terminal 
  emulator, the X window system events supports
  a quick copy paste mechanic. If you left click
  and drag over words, X copies them into a 
  buffer. click down with the middle mouse button
  to paste
 -ctl c and ctrl v don't work to copy and paste
  in some terminals
 -in ubuntu you can use shift ctrl c and v 
 -your GUI probably has a "focus policy" set to
  "click to focus" to match Windows, but X can
  set it to "focus follows mouse" which allows 
  you to mouse over a program without clicking 
  to add input, and it will come to the front 
  only if you click it
 -find this setting in the config program 
  for your window manager.

**try some simple commands
 -$ cal   
  this displays a calendar of the month
 -$ date
  this displays the current time and date
 -$df
  shows free space on disk drives
 -$free 
  shows free memory

**ending a terminal session**
 -$exit
  closes the terminal emulator

**the console behind the curtain**
 -there are "virtual terminals" running behind 
  the gui scenes in most linux distros
 -these can be accessed by hitting ctrl alt F1 
  through F6
 -to switch between them, usealt f1-f6 
 -to get back to gui, use alt f7
 -NOTE: mini pi seems not to be able to switch
  from gui, but can switch between f1, 3, and 5
  like most systems  


/////////////////////////////////////////////////
                CH2 NAVIGATION

**understanding the filesystem tree**
 -unix-like systems like linux use a 
  heirarchical directory structure, meaning 
  the "root" directory holds all subdirectories 
 -the root file is just /, as if you wrote root/
 -unlike Windows, which has separate file 
  systems for each storage device, unix and linux
  have all drives on one tree, with the admin
  deciding where on the tree devices and drives
  are "mounted" (stored)
 

**the current working directory**
 -the folder you are in is your "current working
  directory" 
 -$pwd 
  this Prints Working Directory you are in
 -when you first log in to a terminal, you are
  in the home directory (~ is the shorthand for
  /home/[username here]) 
 -each user is given their own home directory 
  and it is the only place they can write files
  without admin priveleges


**listing the contents of a directory**
 -$ls
  lists contents of a directory, more on this 
  in ch3
 

**changing current working directory (cwd)**
 -$cd directory-name
  this changes working directory to new 
  specified directory 
 -the shell prompt will change to reflect your
  new cwd (unless you took it off default)
 -can use either absolute or relative pathnames 
  to move:
 *absolute*:
 -the file location in relation to the root
    
    /home/pi/Desktop/test.txt
 
 *relative*:
 -the relative pathname of a file is the location
  in relation to your cwd
 -there are two symbols you can use with 
  relative pathnames . and ..
 -the . symbol refers to your cwd and the ..
  symbol refers to your cwd's parent directory
 
  cd ./file (file in cwd)
  cd ../file (file in the parent of cwd
 
 -note ./ is almost always omited, if no 
  absolute pathname is given, cwd is implied
 -you can use multiple .. at once 
 
    cd ../../file/goal

 -that takes you up two files etc.

**facts about filenames**
 -if there's a . in front of a file name, it is 
  hidden. you need to do $ls -a to see them
 -this is done for config and other files, 
  we will do more of this later
 -filenames in linux are case sensitive
 -limit punctuation in filenames to -, _, and .
 -do not use spaces, even though they are 
  technically allowed
 -file extensions don't technically matter either
 you can use any extension you want to name, 
  since programs parse files, not linux itself
 -so a file named "thing" works just as well as
  "thing.txt" as a name


/////////////////////////////////////////////////
        CH3 EXPLORING THE SYSTEM 

**more fun with ls**
 -$ ls 
  shows the contnts of your cwd 
 -$ ls Desktop/folder
  use an argument of a folder name to list out 
  that folders contents without moving your cwd
 -$ ls Desktop/folder Desktop/folder2
  separate folders with spaces to see multiple
  contents   


**options and arguments**
 -you can alter the effects of commands with 
  options and arguments: 

    $ command -option arguments

 -options alter what the command does and the 
  arguments affect what the command acts on
 -options can be case sensitive, so watch out
 -most options are a dash followed by a letter,
  but there are "long options" which are two 
  dashes followed by words 
 
    ls -a // ls --all 

 -the above options do the same thing 
 -short options can be strung together, just use
  a single dash, then multiple short options: 

    ls -alt // the -a, -l, and -t combine

 -short and long options can be used together if
  you want: 

    ls -alt --reverse 


**common ls options**
  -a, --all
  lists all files, even those that are hidden

  -d, --directory 
  ls normally shows you info on files in a dir, 
  but using -d with -l, you can get info on the 
  directory itself (like permissions and links)

  -F, --classify
  append an indecator character to the end of 
  file names (so directories get a / at the end)

  -h, --human-readable
  list file sizes in things like mb and k instead
  of raw bytes
  
  -l 
  display long format (this gives permeisions,  
  file sizes, owners and more, v useful)

  -r, --reverse 
  display results in reverse order, ls normally
  displays files in ascending alphanumeric order
  unless sorted otherwise

  -S
  sort results by file size

  -t 
  sort by when the last modification was, more 
  recent mods at the top


**a longer look at long format**

drw-r--r--  1 root root  6472 Sep 15 14:04 test
1           2 3    4     5    6            7

 -see below for what each field means 

  1
  Access rights to the file, the first character
  says what type of file it is, a - means a 
  regular file, a d is a directory. the next 3 
  are access rights for the files owner, the 
  next 3 are for members of the files group,
  the last three are everyone else. more in ch9

  2 number of hard links to file 

  3 user name of files owner

  4 name of group that owns the file 

  5 size of file in bytes 

  6 date of the files last modification

  7 name of the file 


**determining a files type with file**
 -since filenames are not required to determine 
  an actual file's filetype (ie a .jpg file might
  not actually containg a JPG file), you can 
  double check with the $file command: 

    $ file picture.jpg
    //picture.jpg: JPEG image data, JFIF standard 1.01

  -the file to analyze is an argument for the 
  command


**viewing file contents with LESS**
 -the less command helps you view text files 
 -text files are just one to one mappings of  
  characters to numbers (each char. is a byte)
 -ASCII and unicode are common text types 
 -the less command takes the file to read as 
  an argument: 
 
    $ less /etc/passwd 

 -less is a play on words, since the old unix 
  program was called "more", both programs are 
  examples of "pager" programs 
**less commands**

  PAGE UP key, b
  back one page 

  PAGE DOWN key, SPACE key
  down one page

  UP ARROW, DOWN ARROW  
  up one line, down one line 
  (there is no cursor, its jsut a page view)

  G, g 
  move to end of file, move to sart of file
  
  /characters 
  search for selected characters 
  n
  go to next character set match
  
  h
  display help screen
 
  q
  quit less 

  -notice the similar commands to vi 


**a guided tour**
 -most linux systems are similar and try to 
  conform to the "linux filesystem heirarchy 
  standard" 
 -below are some brief descriptions of the dirs:

 /
  the root dir, where everything is stored 

 /bin
  contains binaries (programs) that must be 
  present for system to boot 

 /boot 
  comtains the linux kernel, initial RAM disk 
  image, and boot loader 

 /dev 
  linux's philosophy of "everything is a file"
  applies to devices, and here is where the 
  kernel maintains a list of all devices it 
  understands 

 /etc 
  contains all system wide config files, and a
  collection of shell scrips that run at boot

 /home 
  each user gets a dir in /home, and here is 
  where they can write files without admin 
  priveleges. this is a safety feature 

 /lib
  contains shared libraries used by core system
  programs 

 /lost+found 
  used in the case of system corruption events 

 /media 
  on modern linux distros, this contains all 
  mountable devices like CDs and USBs that are 
  mounted automaticaly at insertion 
 
 /mnt 
  on older systems, mountable devices are here

 /opt
  used to install "optional" or commercial 
  hardware 

 /proc
  this is a weird dir, it isn't real, it's 
  virtual and maintained by the linux kernel.
  files are readable and gives a view of the 
  the kernel

 /root 
  home directory for the root account 

 /sbin
  contains "system" binaries, these are programs
  that perfom vital tasks reserved for the super
  user

 /tmp
  used for programs that create temporary files,
  some distros clear this each time on boot 

 /usr
  contains all programs and support files used 
  by regular users

 /usr/bin 
  contains executable programs installed by your
  linux distro, can contain 1000s of programs

 /usr/lib
  shared libraries for /usr/bin

 /usr/local 
  where programs that are not included with your
  distro, but indended for system-wide use are 
  stored. it's empty until admin puts stuff here

 /usr/sbin
  contains more sysadmin programs 

 /usr/share
  contains all shared data used by /usr/bin 
  programs like icons and defualt config files,
  background imgs etc etc

 /usr/share/doc
  the documentation for all /usr packages

 /var
  unlike most static directories, this is where
  variable changing data goes, like email and 
  databases

 /var/log
  log files, need to be a superuser to monitor 
  them


**symbolic links**
 -more later, but basically these are like 
  shortcuts that reference files
 -so if you need to referece a file that keeps 
  getting updated, instead of changing all files
  that reference that file with each update, 
  use a symbolic link, then reference that 
 -this means with each update, you just need 
  to change the symbolic link's destinations 

    file > symbolic link foo > mainfile1.0 

      Add updated version of file:

    file > symbolic link foo > mainfile1.1
                              mainfile1.0
 
 -this also lets you keep older versions for 
  easy rollback in case the new version has bugs
 -hard links are similar but more clunky, more 
  on these in next chapter 
