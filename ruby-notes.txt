/////////////////////////////////////////////////////////////
/
/
/             SECTION START: "INTRO TO RUBY" 
/
/
/////////////////////////////////////////////////////////////

=============================================================
%%%                   Introduction
=============================================================

/////////////////////////////////////////////////////////////
                 MINSWAN -Matz and ruby
**MINSWAN**
  Basically, Ruby's philosophy is "natural, but not simple"
 -it was founded by a super nice guy Yukihiro "Matz" 
  Matsumoto in 1990
 -MINSWAN means "Matz is nice, so we are nice"

/////////////////////////////////////////////////////////////
                  Ruby Lecture Intro What Is A Program
 -All programs are converted into machine code 
 -if this is done at run time, it is an interpreted language,
   if it needs to be converted before, it is a compiled 
   program.
 
**Running a ruby program**
 -use the ruby commande

    $ ruby program-name.rb
    // use ruby -v to see what version you are running 
    $ ruby -v 

 -ruby files use the .rb filename 

**words in a program**
 -there are only three possible things in a ruby program:
    -A ruby keyword (only 43 of these)
    -Literal data like strings and numbers
    -Barewords that you define (variables and methods)


/////////////////////////////////////////////////////////////
          Hello World Ruby

**the puts method**
 -The way to print out text into your console in ruby is:

    puts "hello world!"

 -puts stands for outPUT String
 -notice there are no colons after lines 

**A quick comment on comments**
 -to comment a line in ruby use:

    # this is a comment 
    
    =begin
      this is a multiline comment using the
      begin and end keywords
    =end

    ##
    # apparently
    # this is also common


/////////////////////////////////////////////////////////////
        Interactive Ruby Shell (IRB or irb)
**What is the IRB?**
 -The interactive ruby shell is how you open up a ruby shell
  in your terminal to play around with temporary code
 -A Ruby shell is also called a REPL which means
  Read Eval Print Loop
 -it can't save any work

**Accessing a REPL**
 -in the terminal type "irb" to access it, then "exit" when 
  you are finished 
 
    $ irb 
    // now in the ruby shell
    irb(main):001:0> exit # this exits 

 -if you don't have access to the terminal, you can use the 
  site repl.it

**what can you do in the REPL**
 -anything you could do in ruby, like math or test out
  methods, it's just a temporary shell

**loading a file for testing**
 -lets say you just want to test methods or have access to
  the variables of a file, you can use irb to interact
 -simply use the require_relative to the path of the file 
  from the current working directory: 
 -the require should go at the top of the ruby file

    require_relative 'bootcamp-stuff/playground.rb'



/////////////////////////////////////////////////////////////
              Ruby Data types 

**Strings**
 -surrounded by strings, can contain characters and numerals
 -stings all have built in methods like: 

  *.length method*
    -the .length method shows the length of the string, note
     that spaces count as characters

      "this string is long".length
      => 19

  *.upcase*
    -convert all letters to uppercase (if a letter is upper
      already, it will stay that way
    
      "hello there".upcase
      => HELLO THERE

  *.downcase*
    -opposite of upcase,again, no effect on numbers or punc 
      "HEY".downcase
      =>hey

  *.reverse*
    -reverses the contents of the string 
    
       "howdy buddy".reverse
       => "yddub ydwoh" 

  *.capitalize*
    -capitalize the first letter of a string 
  
      "howdy dude".capitalize
      => Howdy dude 

  *.swapcase*
    -flip capitals and lowercase letters 
  
      "Howdy Dan".swapcase
      => hOWDY dAN

**booleans**
  - it's either "true" or "false", notice no capitals 

**integers**
  -just whole numbers, don't use any quotes
  -whole numbers are called fixnums, and decimals are
   floats (when writing a float, always use the 0 to start
   so it's 0.5 never .5)
  -there are a few methods for floats: 

    *.next*
      -used only with fixnums, it will go to the next highest
       whole number

      10.next 
      => 11
      -10.next
      -9
      10.5.next # throws an error, ONLY use fixnums

    *.floor*
      -round float down to the nearest whole number

        1.99.floor
        => 1
        -1.9.floor
        => -2 
      
     *.ceil*
      -round float up to nearest whole number

      1.00000001.ceil
      => 2
      -1.9.ceil
      =>-1 

    *.round*
      -round up or down to nearest whole num (less than 5 is
      down)
    
      1.49.round
      => 1
      1.5.round
      => 2
      -1.49.round
      => -1
      -1.5.round
      => -2

    *.even? and .odd?*
      -check if a number is even or odd, if the conditions are
       met, each returns true: 

        3.even? # false
        3.odd?  # true

 **symbols**
  -symbols can contain letters, digits and undescores
  -they are "lightweight" strings that are easier on your
   computer 

    :symbol_name

 -we will learn much more about these later

**arrays**
 -list, written like pyhton and js
 -here is the Literal Constructor:

    ["hello", "there"]

 -here is ther class constructor: 

    Array.new
    => []

 -here are some common methods for arrays: 

    *.sort and .reverse again*
      -works like you think, numbers are low to high, and
       strings are sorted alphabetically, unlike js
      -ruby allows for method chaining too
      [1, 4, 100, 17].sort
      => [1, 4, 17, 100]
      ["b","a","d","c", "aa", "ax", "ac"].sort
      => ["a", "aa", "ac", "ax", "b", "c", "d"]
      # you can chain methods together to get high to low,
      # and backwards alphabetical
      [1, 4, 100, 17].sort.reverse
      => [100, 17, 4, 1]
   *.max and .min*
     -works like you think: max and min
     [1,9,15].max 
      => 15 
     [12,3,24].min
      => 3
   *.include?* 
     -.include?(value) returns true or false if a value 
      is in an array

    ["foo", "bar"].include?("dog")
    => false
    # note: include? is case sensitvie 
**hashes**
 -this is ruby's key value pair list, made using curly braces
  and arrows like PHP:

    {"key" => "val", "key2" => "val2", "ints work" => 10}

 -hashes also have literal and class constructors, above
  is literal, below is class: 

    Hash.new 
    => {}

**nil**
 -nil is like null in other languages, except that it is
  actually an instance of the nil.class, not just an empty 
  value
 -nil is only equal to nil, which is unlike many languages

**converting types**
 -Ruby cannot do implicit converversions of data types 
 -Ruby needs data types to match if they are going to combine
  so use:
    to_i (int), 
    to_s (string), 
    to_f (float) 
    to_a (array) 
 
  convert data into it's proper type 

    "5".to_i + "5".to_i
    => 10
    "5" + 5 
    => ERROR
   
 -here are the interesting results though:

  -a non-int string to int: 
    "wrong".to_i = 0 
    "5 5".to_i = 5 # it will return the first int it finds
  -booleans to_i creates an error

/////////////////////////////////////////////////////////////
                  READING ERROR MESSAGES 

**3 basic parts**
 -1) the location of the error: (where)

    lib/a_name_error.rb:3:in `<main>':
        |               |      |
      file            line    scope

 -2) the description: (why) 

    undefined local variable or method `hello_world' 
    for main:Object
  
  -3) the type of error (who)
      
      (NameError)

 -the last two will jump around and not always be single 
  or in that order, but the first part is always the where 
  and in that format

**The Ruby Error type and common errors**
 -errors are all descendents from the main Exception class
  and are triggered by different errors
 -there are four common error types: 

  *NameError*
  -happens when a name is invalid or undefined 

   "hello world"
   goodbye world   # this line will cause a name error

 *SyntaxError*
  -when you mess up syntax 

    x = 2
    x =   # Ruby expects a value, so this syntax is wrong 

 *TypeError*
  -two different types trying to interact

    1 + "2"   # error, you can't add ints to strings

 *ZeroDivisionError
  -you can't divide by zero

    12 / 0  # duh


**What is a test suite?**
 -A test is a program written that pulls in other programs
  or functions and checks whether the output is what you 
  expected 
 -learn.co uses the RSpec library to write its tests, and
  stores each test in the "spec" directory
 -you can call the tests by using the "learn" or "rspec" 
  commands in the terminal

**stack trace**
 -the failed tests will print out a "stack trace" which
  finds an error, and then attempts to follow it up the
  stack
 -these are not the error messages themselves, but rather
  a sort of longer trail that gets printed out later in 
  each step of the way


////////////////////////////////////////////////////////////
      DEBUGGING ERRORS IN YOUR RUBY CODE

 -this section is meant as reference for errors in your 
  code and what they mean. 
https://learn.co/tracks/web-development-fundamentals/intro-to-ruby/introduction/debugging-errors-in-your-ruby-code

 -here are previously unseen errors and what they mean

**NoMethodError**
 -this error happens when incorrect data types are being 
  acted upon by built in methods that make no sense
 -it's a bit like TypeError

 like this: 
  total = "64.25"
  num_of_people = 4
  price_per_person = total / num_of_people

 -here, a variable defined as a string is being divided,  
  which makes no sense. There is no method in Ruby to deal
  with dividing a string into an int
 - fix it by converting the type with to_f or removing the
  quotes
 -this issue is common when values are set to nil

**ArgumentError**
 -when a method is called with too many or too few arguments


////////////////////////////////////////////////////////////
          INTRO TO TESTS, RSPEC, AND LEARN

**what's TDD**
 -TDD stands for Test Driven Development and it is when you
  think about what you want your code to do before you start 
  programming
 -it works by coming up with a test for your code to pass,
  and THEN writting the code

**Identifying the desired behavior**
 -come up with a method you need, figure out what arguments
  will be passed into it, and what the output should be
 -then come up with a test to prove this, then write the 
  actual method. Then test it 

**RSpec**
  http://rspec.info/  # the site you should definitely read
  http://blog.teamtreehouse.com/an-introduction-to-rspec
   is another resource to check out
 -RSpec Testing Framework is a DSL, a Domain Specific 
  Language, meaning it is built with Ruby, but adds it's own
  methods and keywords
 -you use RSpec by calling the rspec command and then the
  TEST file, not the file to be tested: 

  $ rspec spec/current_age_for_birth_year_spec.rb
 
**Undesrstanding the tests in the spec directory**
 -all our tests are located in the spec folder
 -common naming is to add spec for tests 

    test: spec/current_age_for_birth_year_spec.rb
    file: current_age_for_birth_year_spec.rb

 -here is the actual test in that folder: 

# expand your window to see code more clearly

require_relative '../current_age_for_birth_year.rb'
 
describe "current_age_for_birth_year method" do
  it "returns the age of a person based on the year of birth" do
    age_of_person = current_age_for_birth_year(1984)
 
    expect(age_of_person).to eq(19)
  end
end

**Overview**
 -the overall goal is to load the file, that code will load 
  the code in current_age_for_birth_year.rb and try to 
  execute current_age_for_birth_year(1984) with the 
  expectation that it returns 19. If so, the test will 
  pass. Anything else will make it fail.

**Breakdown**
 -that first line loads the file you want to test, the
  require_relative says it's a relative path
 -the describe method takes that string and outputs it
  after the test is done, so we can see what the result
  was for this specific test. It then initiates the test
  with the ruby "do" keyword 

 -the it method is where we say what we expect the code to
  actually accomplish in more detail than we could with
  the "describe" method
 - the string following it is just for the output to tell
  us at the end of the test what we expected to happen
 -the it method is followed by another do keyword 
 -the next three lines in this case are the actual test
 -that age_of_person line is actual ruby and it calls the 
  function from our file
 -the expect(), .to, and eq() methods are all RSpec, and 
  the argument for expect is told to equal the argument
  of eq()
 -that's the end of this test, however multiple it/end 
  blocks can be placed in the descibe/end block
 
 -look more into RSpec using that site

**what the learn command does**
 -learn.co has aliased "learn" to look into the spec file and
  execute all files ending in "_spec.rb"
 -it's just a shortcut to using the rspec command and file


*******Time class interlude*******
 -lots of examples use an instance of the Time class
 -more on this later, but for now know 

  Time.now = current time 
    2018-03-15 01:58:28 -0400
  Time.now.day = day of the month
  Time.now.month = month number
  Time.now.year = year, 4 digit format

 you can define the time as well: 

t = Time.new(1993, 02, 24, 12, 0, 0, "+09:00")
            #year, month, day, hour, min, second, timezone
 then use it to check stuff: 

t.monday?   # => false
t.year      # => 1993
t.dst?      # => false (was it daylight savings time?) 





=============================================================
%%%                   Variables and Methods
=============================================================

/////////////////////////////////////////////////////////////
                ABOUT VARIABLE ASSIGNMENT
 -Here is how you assign variables in Ruby: 

    name = "Jeff" 
    last_name = "Conway"
    # these variables all have local scope to the 
    # main scope of the program 
    puts("Hello #{name} #{last_name}.")
    # => Hello Jeff Conway
  
    $global_var = "hello there"
    # variables with $ are in the global scope and 
    # can be affect in or out of methods 

    This_is_const = "yeah"
    # variables that start with capital letters have dif 
    # rules and are called constants (more on this later)

**Naming rules**
 -don't use pucntuation, can't start with a number, can't
  use -, and prefered multi-word style is snake case, 
  which uses undescores_like_this,
 -variables can end with numbers, and variables are case 
  sensitive

**Variable types**
 -Ruby is dynamically typed, so that means variable types
  can be switched and do not need to be explicitly defined
 -It is also strongly typed, so variables will never be 
  coerced into another type without being explicitly changed

**creating/reassigning variables**
 -it's super easy 

    new_var = "mike"
    new_var = "now it's not"

**scope**
 -Ruby has local and global variables just like other 
  languages, more on this later 

**pass-by-value/pass-by-referece**
 -In Ruby, basically everything is an object, there are 
  no primitive types 
 -take a look at this code

    sound = "squeak"
     
    # We can peek at the value of sound by typing its name
    # into the IRB shell like so
    sound
    # => "squeak"
     
    # here we semingly modify the string 
    sound.upcase
    # => "SQUEAK" 

    # but yet it remains 
    sound
    # => "squeak"

 -so variables really just point to data, but unlike other 
  languages which have primitive types (variables can point
  to literal data like "hello" or 3) that simply exist, 
  and reference types (variables point to an object with a
  value that can be changed from many different locations),
  Ruby only has objects 
 -strings are actually instances of the String class, 
  numbers are instances of the Number class, etc 
 -this is a problem though, since sometimes you have to 
  be able to point to simple values without actually 
  changing some central object. We can't always worry about
  changing everything back   
 -to mimic the behavior of primitive types, Ruby uses 
  pass-by-value, which is when a value is copied over 
  from an object (in this case "squeek")
  and THEN altered without affecting the original
 -to get that familiar "reference type" behavior, where a 
  variable doesn't just store simple data but rather a 
  reference to a single object, Ruby uses pass-by-reference
  instead 
 -NOTE: you can check what class an object comes from by
  using the .class method 
  
    "hello".class 
    # => String 


/////////////////////////////////////////////////////////////
    SIDE NOTE: string evaluation, ',",`,  and puts v print
    and executing commands from Ruby

**single vs double quotes**
 -double quotes allow for string evaluation, or interpolation
  while single quotes only allow for concatenation: 

  puts("This works just #{fine_var}")
  puts("this " + "also works " + fine_var + ".")
  puts('this doesn\'t work #{fine_var}')
  puts('this ' + 'also works ' + fine_var + '.')
  # notice in single quotes, the single quote needs escaping

 -so like PHP "" allows for evaluation of interpolated code
  and special characters like \n and \t, while single 
  quotes do not 
 -in terms of performance, this is almost no difference

**other options besides quotes**
 -If your text has a lot of embedded quotes, you can also 
  use string delimeters 
 -%Q/This is the same as a double-quoted string./ 
  %/This is also the same as a double-quoted string./ 
  %q/And this is the same as a single-quoted string/

**Concatenation vs interpolation**
 -concatenation is just + and interpolation is #{}
 -you can put code, not just variables into #{} 

    puts("like this #{"3".to_i + 4}")
    # => like this 7

**puts vs print**
 -puts always adds a newline character after whatever 
  argument you pass into it, print does not, the cursor 
  will remain at the end of the string 
 -this is useful when printing messages to users that 
  require info back 
 
    print( 'Enter your name: ' ) 
    name = gets() 
    puts( "Hello #{name}" )
   
 -this leaves the cursor right where the user would 
  expect the input, after "name: "
 -it should also be noted that puts and print do not need 
  (): 
    foo = "this is also fine"
    puts "this works"
    puts"this works"
    print "just fine"
    print"just fine"
    print("same")
    puts("thing")
    puts foo
    print foo

 -this is because in ruby doesn't actually need parentheses
  for its method arguments, some people just prefer it

**backquotes**
 -Backquotes allow ruby to execute commands in the shell:

    puts(`ls`)
    # this would return your directory for example
    puts(`> foo.txt`)
    # you can do anything, like even make files 

 -you can also use these formats as well: 

    puts(%x/ls/) 
    puts(%x{ls})
 
 -and embed it into a string like this: 

    print( "Goodbye #{%x{cal -y}}" )

 -However, when you do this, the command will always evaluate
  first, and then the string will print



////////////////////////////////////////////////////////////
                RUBY VARIABLES TYPES 

**local variables**
 -local variables are unique to their scope, if you define 
  a variable inside a method, it won't be "seen" in the main
  scope and vice-versa 
 -this is different from say, JavaScript where variables can
  see "up" to the next scope if need be, but not down
  (eg a variable defined one scope above a function can 
   be seen from inside the function, but none of the
   functions can be seen outside of it)
 -here is ruby local scope in action: 

    other_loc = "the function can't see me!"
    def my_method
      puts other_loc # this won't work
      local_variable = "Only my method knows about me!"
    end
   
  puts local_variable #this wont work

**global variables**
 -global variables have global scope, so they can be 
  accessed from anywhere in the program:

    $global_var = "All can see me!"
    def my_method
      puts $global_var      # this works
    end
    puts $global_var      # this works as well

 -globals should be used sparingly, if at all, since they
  have a tendency to break encapsulation and things in
  general 

**Constants**
 -these variables are either capitalized or in all caps
 -they can't be redefined
 -they have either local or global scope and can be 
  defined inside classes and modules, but not methods 
    
    Constant = "i'm a constant"
    CONSTANT = "i'm a different value" # don't name var like
                                       # this ever
    CONSTANT = "Reassigning will throw an error"

    $CONST = "I'm me and global"



/////////////////////////////////////////////////////////////
                  DEFINING METHODS
**method definitions**
 -here is an example method: 
 -method signature is the first line 

    def say_hello    # method signature 
      puts "hello"   # method body
    end              # method closing 

    say_hello        # method call

 -this is the very basic skeleton of a method 
 -notice again that () are not necessary to call the method
  (unlike js, where a method without () won't call it, 
   but is simply a reference to that function)

**#methods, methods? and methods!**
 -often when writing about ruby code, you will see methods
  prefaced with a #. 
 -this is only used in articles to help readers quickly 
  know that #say_hello is a method, not a variable or class
 -when coding, never actually write this, since that will 
  comment it out
 -a method that ends in a ?, like .include? is also just a
  convention, it means that it will return a boolean. 
 -it has no syntactic value, it could return a bool and do 
  other stuff, it's just a naming convention rubyists like
 -a method! means that the method likely alters the actual 
  value of the object, it is doing a pass-by-reference,
  not pass-by-value
 -so string.capitalize will capitalize a copy of the sting
  but string.capitalize! will capitalize the original value
 -the exclamation at the end is a sort of convention? as in, 
  some ruby methods follow it and work how you expect, but 
  some librarys and frameworks do no. methods with no ! can
  alter the actual value, it's not syntax, it's just a naming
  convention the makers of ruby agreed upon
 -as in you can't just add a ! to a method and change its 
  behavior, there had to be a method written with that 
  behavior in the core function


/////////////////////////////////////////////////////////////
                METHODS AND ARGUMENTS 
**arguments**
 -add arguments to your methods to pass in values: 

    def say_hello(greeting, name)    
      puts "#{greeting} #{name}, how are you?"  
    end              

    say_hello("HIYOOOO", "Steve")        

 -simply put parameters in the method signature, comma 
  separated, and then pass in theexact number required in
  the method call
 -messing up arguments leads to an ArgumentError so be 
  careful
 -without the () this is what it looks like: 

    def say_hello greeting, name     
      puts "#{greeting} #{name}, how are you?"  
    end              

    say_hello "HIYOOOO", "Steve"         

 -I personally prefer (), but apparently a lot of rubyists
  don't. Because life isn't fair 
 -in fact some DSLs (like RSpec) choose to omit these ():

    # rspec 
    describe "MyRubyThing" do
      it "runs" do
        # test here
      end
    end      

    # same thing as: 
    describe("MyRubyThing") do
      it("runs") do
        # test here
      end
    end

**bareword**
 -those parameters greeting and name are technically 
  barewords and become local variables once inside 
  the method. Just a fun fact


/////////////////////////////////////////////////////////////
                METHOD DEFAULT ARGUMENTS 
**Using defualt values**
 -to avoid argument errors and make it easier to use methods
  with default values unless otherwise stated, use 
  default arguments: 

    def greeting(name, greeting = "Hello")
      puts "#{greeting}, #{name}
    end 

    greeting("tom")
    greeting("steve", "yo yo")

 -Always put default arguments las in your code, and always
  list out your arguments in the proper order. 
    -otherwise, you may get some strange results/broken 
      code when you don't expect it 

**ArgumentError**
 -you can tell a method needs defualts becuase if you 
  run it with no arguments, or two few required, the error
  will give you a list of the possible arguments it could 
  accept, like [1..2] for 1 OR 2 arguments possible



/////////////////////////////////////////////////////////////
        RETURN VALUES

**Puts and print in depth**
 -as stated, puts uses a newline at the end, print doesn't
 -the way they work thoush is using the $stdout global 
  variable provided by ruby
 -the $stdout accesses your terminals stdout, which is how
  you can see it in the terminal
 -becuase of this, it can also be piped like any other stdout

    # say_hello outputs "Hello!"  
    $ ruby say_hello.rb > foo.txt
    $ cat foo.txt
    Hello!

**Returnin values**
 -Everything has a return value 
  look at this table to see examples of return values: 

    
Code	                  Return Value
"Hello world"	        "Hello world"
6 + 3                  9
president = "Obama"   "Obama"
total = 6 + 3	         9
puts "hello world"	   nil
print "hello world"	   nil

 -notice that puts and print return a nil value, this is
  bcause they output the string, then return nothing, hence
  nil value

**methods and return values**
 -methods will automatically return the value of the last 
  statement by defualt
 -so this method returns "welcome to flavor town"

  def restaurant
    restaurant_name = "Guy's American Kitchen & Bar"
    cuisine = "american"
    motto = "Welcome to Flavor Town!"
  end

 -however, this returns nil: 
    def print_name
      puts "Guy Fieri"
    end
   
 -to make it return "Guy Fieri" you can do this weirdness:

    def print_name
      puts "Guy Fieri"
      "Guy Fieri"
    end

 -just be sure not to switch the order, since puts always
  returns nil

**the return keyword**
 -you can tell a method to return a specific value and exit
  out of a method immediately with the return keyword: 

    def stylish_chef
      best_hairstyle = "Guy Fieri"
      return "Martha Stewart"
      "Guy Fieri"
    end

 -even though "Guy Fieri" is the last statement, he is 
  rightfully ignored and the return value is returned 
  and the method is exited 
 -most rubyists ignore return values unless explicitly needed
  like when you want to get a value earlier in the function
  
    def change_my_name
      name = "Frank"
      puts name.reverse
      return name
    end
    # this returns an un-reversed name while print reversed

**mind your returns**
 -either way, make sure that your methods return the right 
  thing.
 -sometimes it's best to explicitly state return, since it
  is obvious to others reading your code what value you are
  working with


/////////////////////////////////////////////////////////////
      STRING INTERPOLATION

**see your earlier section**



/////////////////////////////////////////////////////////////
          DEBUGGING WITH PRY

**What is Pry?**
 -Pry is another Ruby REPL that lets you pause your program
  at a point and interact with it, so you can see what 
  variables have what value and what methods do what 
 -it is activated with the bindind.pry method 

**binding**
 -binding is a built-in Ruby class that lets you encapsulate
  the current scope of the object and retain them outside 
  their original context
 -so using binding.pry takes the scope you are in, and lets
  you "pry" into it with a Ruby shell

**instalation and use**
 -jsut cd into your home directory and use 
    
    $ gem install pry

 -that's it, it's installed 
 -to use it in a program put a require method at the top:

    require 'pry'  # you only need single quotes 

 -now when you run your program, it will freeze at that point
  specified and show you the lines around binding.pry, and
  then let you see variable values, and even change variable
  values 
 -once you type "exit" to get out of the shell, 
  the program will continue, and if you changed 
  anything, it will then work with whatever you gave it

**Debugging**
 -obviously useful, no more printing breakpoints, you 
  can simply inteact directly
 -pry is triggered whenever and wherever the interpreter 
  hits it, so even if you never call a method, 
  if binding.pry is in one and you fire a test with RSpec,
  you will be able to go into the shell during the test 
  (but not if you just use the command ruby on the file, 
  since you never call the method it's in)
 -point is, testing triggers pry
 -be careful of return staments coming before pry, you won't
  ever get to it! 



/////////////////////////////////////////////////////////////
            RANGES and RANDOM NUMBERS 

**Ranges**
 -A range is a set of values with a beginning and end
 -they can be strings or integers, but not both at the 
  same time 
 -do not use floats
 -they are made by specifying the beginning and end of the
  range, then using either the ".." or "..." range operators

    (1..6) 
    ("a".."z")

**.. vs ..."
 -using the .. operator means both the beginning and end are 
  inclusive, the ... operator means the end is NOT inclusive

**stepped ranges**
 -you can generate steped ranges using the #step method: 

    (1..20).step(2).to_a
    => [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    
 -step takes the argument of however many steps to take 
  after the first entry in the range
 -NOTE: when using step you must use () when declaring the
  range, otherwise it fails
 -also, you do not need to convert to an array, that was 
  just for a nice looking return value

**ints and strings**
 -ints are straightforward: 

    foo = (1..9)
    =>1,2,3,4,5,6,7,8,9
 
 -strings are less so: 

    bar = ("bat".."bee")
    => ["bat", "bau", "bav", "baw", "bax", "bay", "baz", "bba", "bbb", "bbc", "bbd", "bbe", "bbf", "bbg", "bbh", "bbi", "bbj", "bbk", "bbl", "bbm", "bbn", "bbo", "bbp", "bbq", "bbr", "bbs", "bbt", "bbu", "bbv", "bbw", "bbx", "bby", "bbz", "bca", "bcb", "bcc", "bcd", "bce", "bcf", "bcg", "bch", "bci", "bcj", "bck", "bcl", "bcm", "bcn", "bco", "bcp", "bcq", "bcr", "bcs", "bct", "bcu", "bcv", "bcw", "bcx", "bcy", "bcz", "bda", "bdb", "bdc", "bdd", "bde", "bdf", "bdg", "bdh", "bdi", "bdj", "bdk", "bdl", "bdm", "bdn", "bdo", "bdp", "bdq", "bdr", "bds", "bdt", "bdu", "bdv", "bdw", "bdx", "bdy", "bdz", "bea", "beb", "bec", "bed", "bee"]
 
 -notice how it hits every permutation alphabetically, if you
  just did ("a".."r") though, it would simply list the alphabet
  
**MUST be ascending**
 -ranges must be in ascending order, both numerically and 
  alphabetically

**converting to array**
 -converting to a array is easy: 

    foo = (1...11).to_a
    or 
    foo.to_a  # if you hadn't in the definition

 **ranges are iterable**
 -you can use loops, include, max and min and many other 
  methods with ranges, you do not have to convert them into
  arrays first:

  # Assume a range
  digits = 0..9

  puts digits.include?(5)
  ret = digits.min
  puts "Min value is #{ret}"

  ret = digits.max
  puts "Max value is #{ret}"

  ret = digits.reject {|i| i < 5 }
  puts "Rejected values are #{ret}"

  digits.each do |digit|
     puts "In Loop #{digit}"
  end

**ranges as conditions** 
 -ranges can be used in case statements: 

    score = 70

    result = case score
       when 0..40 then "Fail"
       when 41..60 then "Pass"
       when 61..70 then "Pass with Merit"
       when 71..100 then "Pass with Distinction"
       else "Invalid Score"
    end

    puts result # "pass with merit"


**ranges as intervals** 
 -ranges can be used to check if a value falls with a certain
  range: 


    if ((1..10) === 5)
       puts "5 lies in (1..10)"
      # true
    end
    

    if (('a'..'j') === 'c')
       puts "c lies in ('a'..'j')"
      # true 
    end

    if (('a'..'j') === 'z')
       puts "z lies in ('a'..'j')"
      # false 
    end 


**random number generation**
 -ranges are great for quickly doing integer randoms: 

    rand(11) 

 -is a random whole number between and including 0 and 10
 -whatever argument you pass to rand() is the exclusive max
   and 0 is the inclusive min
 
 -but what if you want a specific range, say a dice, that 
  included everything 1 through 6, just use an inclusive 
  range: 

    rand(1..6)

 -to get a random float: 
 
   rand() 

 -this generates just a random float between 0 and 1
 -to get a random float in a range use this function: 

   def range (min, max)
     rand * (max-min) + min
   end

 -you can't use the range .. operators because they don't 
  work on floats 


//////////////////////////////////////////////////////////////
        METHOD SCOPE 
**scopes**
 -variables named outside a method can't be accessed inside 
  methods, variables named inside a method can only be 
  accessed inside THAT method 

    name = "joe"
  
    def say_hi()
      name = "tim"
    end 

    say_hi
    # > "tim"
    name 
    # > "joe"

 -the only way to get a variable into a method is to pass 
  it in as an argument
 -the only way to get a value out of a method is to return it

    evil_monster = "Bowser"
     
    def princess_peaches_castle(evil_monster)
      puts "#{evil_monster} is kidnaping Princess Peach!"
    end
     
    
    princess_peaches_castle("craig")
    # > "craig is kidnaping Peach!"

    princess_peaches_castle(evil_monster)
    # > "Bowser is kidnaping Peach!"

 -so even though evil_monster LOOKS like it was passed in, 
  that evil_monster parameter is a bareword with local 
  scope to that function, as we see when we define it 
  as the argument string "craig"
 -the only way to get the main scope evil_monster into that 
  method is to actually pass it as an argument


//////////////////////////////////////////////////////////////
                      MATH IN RUBY 

-all basic arithmatic operators are here
  +, -, /, %, **

 -division by default returns integers without rounding 
  (they just remove the decimals so 5.999 would be 5) 
 -to get a float answer, use floats or at least one 
  float: 

    9.0 / 4 = 4.5

 -PEMDAS is how ruby works, but you can use () to alter it
  as usual
 -the Math class can do a lot, check it out for more
 -a common one is 

    Math.sqrt(x) 

  to find the square root



//////////////////////////////////////////////////////////////
        BOOLEANS AND TRUTHINESS 

**booleans**
 -in ruby, booleans are just true and false, no capitals 
  like python or YES NO in obj-c

**flow control**
 -this is basically and if x do y statement, they can get 
  much more complex than that
 -it's flow control becuase you are controlling the flow of
  the program 

**truthy and falsey**
 -you don't have to literally have true or valse as a value
  to be "truthy" or "falsey"
 -however in ruby...literally everything is truthy except for
  the value nil and the value false and FALSE 
 -this is unlike js where empty strings, 0, empty arrays, 
  empty objects were falsey

**Determining truthiness**
 -the bang operator "!" reverses the truthiness of a value, 
  but !! will negate the negate to show the original value 

  !!true # true
  !true # false 


//////////////////////////////////////////////////////////////
    BOOLEAN OPERATORS 
**booleans**
 -booleans are their own data types so true is an instance of
  TrueClass and false is FalseClass 
 -just be aware of this for now 

**Boolean operators**
 ! = single bang means NOT
 && = AND
 || = OR
 == = values are equal 
 >, <, >=, <=  = all the stuff they always do
  NOTE:
 === is used for equality in case statments, NOT checking 
   if the two values are the same type, Ruby does not coerce,
   so == checks for data types automatically  

**what can be compared**
 -strrings can be compared to strings to see if ALL char. 
  match, int and floats values, and of course variables 
  of any of these 

**.class comparisons** 
 -as stated .class will show the class of a value, and you
  can use that to make sure a variable is the right class: 

  animal = "pig"
  human = "steve" 
  animal.class == human.class # both equal String so this is 
                              # true



/////////////////////////////////////////////////////////////
    Interlude: getting values from the command line 

**user interaction**
 -if you want to get a variable value from the user, 
  like say a username, then use the gets() method 

    name = gets()

 -the gets method waits for user input, then continues 
  once the user hits enter (pythong raw_input())
 -HOWEVER, when the user hits enter, that is technically 
  addin a newline \n character to the end of their answer
 -to trim this, use the .chomp method 

    name = gets.chomp  # remember () are not needed 

 -this takes just the username with out \n on the end 



/////////////////////////////////////////////////////////////
      RUBY CONDITIONALS (IF, ELSIF, ELSE)

**if, elsif strings**
 -here's the syntax: 

  if (condition is true) 
    # do this 
  end 

  if (condition)
    if equals one thing do this 
  elsif (condition)
    if another do this 
  elsif (condition)
    these are unlimited in number 
  else 
    catchall if the others fail
  end 

 -so don't forget the end keyword 

**a note on flow control**
 -be wary of conditions that meet two checks, the second it 
  hits one that matches, it will exit the conditional check 
 -so put the most specific case first, then the least specific
  case last
 -below is a bad example, you will never get to "it's 6" 
  since 6 > 4, so it would hit the first one and exit out 

    num = 6
    if (num > 4) 
      puts "it's bigger than four"
    elsif (num == 6)
      puts "it's 6"
    else 
      puts "it's a number"
    end

 -you would want to put the more specific 6 check before the
  general greater than 4 check 



/////////////////////////////////////////////////////////////
            OPERATORS AND CONDITIONALS 
        (TERNARY OPERATOR AND STATEMENT MODIFIERS)
**ternary operator**
 -Use this familiar sytax to replace simple if else
 -sytnax is just :

    conditional ? action_if_true : action_if_false

 -in ruby this is a good example

  age = 1
 
  baby_status = age < 2 ? "baby" : "not a baby"


**statement modifiers**
 -add a conditional to the end of a statement to keep it 
  from evaluating if the conditional is false 
 -it's self explanatory: 

    this_year = Time.now.year
    puts "Hey, it's 2015!" if this_year == 2015

 -now that code will only print if it's 2015
 -the other statement modifer keyword is "unless" which 
  is basically a NOT check: 

    this_year = Time.now.year
    puts "Hey, it's 2015!" unless this_year == 2015

 -now it will print whenever it is NOT 2015 


/////////////////////////////////////////////////////////////
        RUBY CASE STATEMENTS 

**A less smelly alternative** 
 -lots of if elsif options is longer than you need sometimes
 -if you're only essentially checking if a value equals a 
  specific outcomes (ie not a check like val < 6, but more
  like val == 6) then use a case statement
 -you can also use case statements to check something 
  is within a range, a regex, or a lambda (more on lambda 
  later)
 -btw, it is called "code odor" when code is overly 
  complex, so removing the "smell" with a case statement
  is better 

**syntax** 
  -the value to check goes next to the case keyword 
 -the conditions go after the when keyword, 
  and the outcome goes below,
 -notice there is still a catchall "else" block and an 
  end statement 
 -however, you do not NEED to put in the else statement 
  if you do not need one 

  name = "Alice"
  case name 
 
    when "Alice"
      puts "Hello, Alice!"
    when "The White Rabbit"
      puts "Don't be late, White Rabbit"
    when 2..10
      puts "this is just an example of a range"
    when "The Mad Hatter"
      puts "Welcome to the tea party, Mad Hatter"
    when "The Queen of Hearts"
      puts "Please don't chop off my head!"
    else 
      puts "Whoooo are you?"
  end

**How does it actually work** 
 -Basically each condition is checked like 
  
    is value === check
  
  and if so it runs that block, then exits 
 -note that is a === not a ==, case use 3 =, which is 
  slightly different
 -== just checks at the obj level if both values are the 
  same class, however === overides that to allow checks 
  between different objects (like int and regex or range)


/////////////////////////////////////////////////////////////
      INTRO TO LOOPS 

**times iterator**
 -one of the simplest ways to loop is using the times
  iterator: 

    10.times {puts "hello there"}
    10.times do 
      # both ways work with single or multiple lines 
      puts "hello there" 
    end 

 -either one works, brackets can be interchanged with 
  the "do" and "end" keywords 
 -but what if you want a counter? then use an iteration
  variable, most often depcted as "i"

    10.times {|i| puts i}

 -times only works on integers, and it's return value 
  is the number of times it looped (so 10 in this case) 

**quick note on | | **
 -braces define an anonymous function, meaning that they 
  can accept certain variables from certain methods 
 -only certain methods will use and pass variables to 
  anonymous blocks 
 -with .times it will pass an iteration variable, so 
  use |value| to assign that value 
 -with .each though, it will pass the |key,value| values 
  for each iteration (more on the .each method later)
 -you can however just pull in variables from the main scope
 (or whatever scope the block is in) as well 

    name = "tim"
    5.times do |i|
      puts i
      puts name
    end 

  that will print out the iteration variable i and the name 
  "tim" 5 times 
 
 -NOTE: this is one of those things you should revisit when
  you know more 
 
/////////////////////////////////////////////////////////////
  LOOPING 
**looping** 
 -here is the simplest loop in ruby, notice the different 
  incorporation of the couter, the break keyword, and 
  the condition check
 -the loop keyword jsut tells ruby to go forever, you 
  HAVE to include a break somewhere inside it to end 
 -the "break" keyword has the loop exit at that very line
  and can be used with statement modifiers to be more 
  concise 
 
    counter = 0
     
    loop do 
      counter += 1
      puts "Iteration #{counter} of the loop"
      break if counter == 10
    end

**Add assignment and other operators** 
 -ruby has no increment operator (i++), but it does have the
  familiar assignment operators: 

  i = i + 1  == i += 1
  i -= 2   # subtract it 
  i *= 2   # multiply it
  i /= 2   # divide it 
  i **= 2  # square it 


/////////////////////////////////////////////////////////////
      WHILE AND UNTIL LOOPS 
**while loops**
 -a much more concise construct than just the loop keyword
 -matches most other languages syntax:

    counter = 0
    while counter < 20
      puts "The current number is less than 20."
      counter += 1
    end

**until loop**
 -basically the inverse of a while loop
 -a while loop does something as long as a condition is 
  true, an until loop does something UNTIL something is 
  true 

    counter = 0
    until counter == 20
      puts "The current number is less than 20."
      counter += 1
    end


/////////////////////////////////////////////////////////////
      FOR LOOPS 

**syntax**
  for counter in 1..40 do
    puts "The current number is #{counter}."
  end

  # OR
  counter_range  = 1..40
  for counter in counter_range do
    puts "The current number is #{counter}."
  end

 -like you'd expect, you can substitute the counting 
  range for a variable of a range



/////////////////////////////////////////////////////////////
    CLOSER LOOK AT RSPEC 
**before hook**
 -you might notice in some tests this pattern: 

    before(:each) do
      #code 
    end

 -that's a before hook, and it allows you to execute code 
  before you run tests 
 -the "before" keyword takes a symbol to define its scope:

    before(:each) blocks are run before each example
    before(:all) blocks are run once before all of the 
      examples in a group
    
 -there are also after blocks, so you can have code that 
  exectues before and after certain code
 -here is the order of each block execution:

    before suite
    before all
    before each
    after each
    after all
    after suite


/////////////////////////////////////////////////////////////
      PAUSING A PROGRAM 
**sleep method**
 -telling a ruby program is super easy 

    sleep(num_secs)

 -the number can be a float or an int
 -if you install the active support library, you can use
  .minutes and .hours and .days to pause as well

 -to do this do gem install activesupport 
 -then require 'active_support/all'
   -you actuall only need part of it, but I can't quite
    figure out which, if it comes up in a project, find it

/////////////////////////////////////////////////////////////
      BLACKJACK CLI and CLI APPS 
**puts, print and $stdout**
 -both puts and prints router their arguments into the 
  command line stdout file using the ruby global 
  variable $stdout

**running programs and runners**
 -just do ruby <program name>
 -but the structure of the ruby file helps facilitate clean
  code 
 -set up your code into little helper methods, then call them
  all inside a runner method (usually #run_program), then 
  call that runner method: 

# main program 
def welcome
    puts "HI!"
end
 
def ask_name
    puts "What is your name?"
end
 
def store_name
    gets.chomp
end
 
def personalized_welcome(name)
    puts "HI, #{name}"
end
 
def run_program
    welcome
    ask_name
    name = store_name
    personalized_welcome(name)
end

run_program

 -you can also create another file, called a runner file 
  that requires the main program, and then only contains 
  one other line, a call to the run_program method 

require_relative 'playground.rb'

run_program

**testing your file and stubbing**
 -as prev. noted, RSpec fails when using gets, so you have 
  to fake it with a process called "stubbing" 
 -stubbing is when you fake what user input SHOULD be and then
  act on that in the test 

 # RSpec code 
 expect($stdout).to receive(:puts).with("Type 'h' to hit or 's' to stay")

expect(self).to receive(:get_user_input).and_return("s")

 -so you see it expects that $stdout global variable to 
  recieve puts with a message, and then it tells the test 
  that the user input is now "s"
 -stubbing will be explained in greater detail later

//////////////////////////////////////////////////////////////
        INTRO AND USING AN ARRAY 
**creating a new array 
    
    arr = []
    arr2 = Array.new 
    arr_with_stuff = ["value", "separated by comma"]
    Array.new(['a', 'b', 'c'])
    arr_with_other = %w(cat dog mouse)

 -that last one is a shortcut, it uses spaces instead 
  of commas and quotes, those words are all strings 
  it will not take variable names and it turns symbols 
  into strings 

**values of items**
 -to get the value at an index, use the familiar bracket
  notation 

    arr[2]
    arr[-1] # negative numbers go from the end

 -you can also get the first and last values of an array 
  using the first and last methods: 

    arr.first 
    arr.last

 -you can also get a slice using a bracket notation with 
  range: 

    arr[1..4]   #1st to 4th index
    arr[1...4]  #1st up to 4th index
    arr[3..-2]  #3rd index to the second to last index
 
 

**Adding items to the end**
 -you can use the push method or the shovel operator (<<)
  
  arr.push("new_val")
  arr << "another"

**Add items to the start**
 -use the .unshift method 

    famous_cats.unshift("nala cat")

**inserting an item at an index**
 -use the insert method to insert values after the given
  index 
 -negative indexes can be used as well

   arr.insert(3, "t", "yu")
    => ["1", "2", "3", "t", "yu", "5", "6", "7", "8", "9"]

 -insert permanently chages the array it adds to

**pop and shift to remove items at end and start**
 -like js, use the pop method to remove a value from the 
  end of an array and return that value, and use shift 
  to do it from the start of an array 

  last_value = arr.pop
  first_value = arr.shift
  last_2values = arr.pop(2)
  first_2value = arr.shift(2)
  # you can also specify the number of items to remove with
  # an argument, and it will return an array of those items
  

**actual changes vs pass-by-values**
 -pop, shift, unshift, push, insert all actually change the 
  values and order in an array, however not all methods 
  do this 

**deleting by value/index** 
 -use the delete method to delete a value, use delete_at 
  to delete the value at an index: 

  a = [ "a", "b", "b", "b", "c" ]
  a.delete("b")                   #=> "b"
  a                               #=> ["a", "c"]
  a.delete("z")                   #=> nil
  a.delete("z") { "not found" }   #=> "not found"

  a = %w( ant bat cat dog )
  a.delete_at(2)    #=> "cat"
  a                 #=> ["ant", "bat", "dog"]
  a.delete_at(99)   #=> nil

 -both have a return value of the item they deleted, or
  nil if no value is found 
 -delete ACTUALLY alters the array and its contents

**#each and each_with_index**
 -the each method executes a block of code for each 
  value: 

  a = [ "a", "b", "c" ]
  a.each {|x| print x, " -- " }
 
 -just remember to pass the index through with pipes 
 -the return value is the array 

 -you can also get the index by using each_with_index: 

    arr.each_with_index { |val,index| 
      puts "index #{index}: #{val}"
    }

 -just always be aware that value will be passed 
  along first, then index, no matter what you call them
 -also, the return value is still the original array 

**include? - see if an array has a value**
 -as stated the include? method returns true or false if 
  the value is in an array 

    arr.include("hello")
    # be aware that it is case senstitive 

**see if array is empty**
 -the empty? method returns true if an array is empty
  false if not

    arr.empty?

**length of an array**
 -use length (apparently fastest), size, or length: 

    arr.length
    arr.size
    arr.count 

 -the size method is just an alias for length, but count 
  has some extra features if your ever curios

**join into a string/split string into an array**
 -the join method joins an array into a string, and you 
  can pass a string as an argument to go between values: 

    arr.join(", ")

 -the split method works the opposite way, it will split
  a string into an array. It takes an argument of where to 
  split the string, otherwise it splits by space
  (to get each character alone, specify "" as the argument

    "this is a string".split
    => ["this", "is", "a", "string"]
    
**sort and sort!**
 -the sort method sorts arrays alphabetically or numerically
  in the ways you would think (not like js) and it works on
  floats and ints together 

    arr.sort

 -however sort returns a copy, while sort! actually alters 
  the original value 
 -sort will break if their are strings AND numbers, so 
  if you for some reason want both, convert all the numbers
  to strings and then sort. sort will put the numbers first 
 
**reverse and reverse!**
 -since sort only goes low to high or alphabetical, you 
  can use reverse to reverse the order of the array 

    arr.reverse 

 -reverse! does permanent change to the array

**print vs puts an array**
 -it should be noted it you just puts an array, each value 
  will go on its own line, but if you print an array, it 
  will show you the bracket format you would expect



**map and map!**
 -map iterates of a list and executes a code block on the 
  value, jsut like each 
 -however, instead of returning the whole array, it returns 
  the value from the block in a new array
 -this means if you use map! you can alter the original list: 

    [1, 2, 3].map { |n| n * n } #=> [1, 4, 9]

 -however, if at any point in the map code block it hits 
  a return keyword, the whole thing stops and instead of
  return multiple values in an array, it will return that 
  single value: 

  # i want different outcomes, sure, but that "return letter"
  # will break things, you have to use the implicit return
  # attribute of ruby, like the other two examples 
  message_arr.map! do |letter|
    index = alphabet.index(letter)
    if index == nil 
      return letter 
    elsif index == 0
      letter
    else 
      letter = alphabet[index + cypher]
    end
  end

**concat and joining arrays**

  arr1.concat(arr2, arr3....)

  use the concat method to join, in order of arguemnt
  other arrays into an array
 -you can also just use a single array
 -concat is permanent and will break up all arrays added
  so that there are no arrays in arrays, just one array of
  all items 

**flatten an array of arrays into a single array 

  arr = [[1,2,3], ["a","b","c"]]
  arr.flatten
  # [1,2,3,a,b,c]
  arr 
  # [[1,2,3], ["a","b","c"]]
  # notice it isn't permanent unless using flatten!



**remove duplicate items with uniq**

    arr = [1,2,1,3,4,5]
    arr.uniq 
    # [1,2,3,4,5]
    arr.uniq! # this permanently removes the duplicates 
    
//////////////////////////////////////////////////////////////
      ENUMERATORS INTRODUCTION

**enumerators**
 -enumerators allow for iterative actions over data structures
  like arrays and hashes
 -basically, they do things to each thing in list of countable
  things 
 -the common ones are #each, #map (#collect), #select, #find,
  #delete_if, #include?, #any 

**#map vs #collect**
 -map is just an alias for collect, they both return a new
  array of values created from a block, it's just that many
  languages call that function "map" so ruby just added the 
  name

**#map vs each**
 -as stated before, map returns a new array of values,
  or alters the original, while each returns only the old 
  array

**#select **
 -select compares each value to a test, and then returns the
  ones that meet the conditional in a new array: 

    cool_nums = [1, 2, 3, 4, 5]
 
    def even_nums(nums)
      nums.select do |x|
        x.even?
      end
    end
     
    even_nums(cool_nums)
    #=> [2, 4]

**#find**
 -pretty much #select, but once it finds the first match, 
  it just returns that single value: 

    [1, 3, 5, 7].find do |num|
      num.odd?
    end
      => 1

**#delete_if**
 -if a condition is true, the value will be deleted 
 -the return value is the partially deleted list 

    [1, 2, 4, 7].delete_if do |num|
      num.odd?
    end
    => [2, 4]

**#any?**
 -returns true or false, true if any of the items in an 
  array meet a condition, false if not: 

    words = ["are", "any", "of", "these", "words", "longer", "than", "four", "letters"]
    words.any? do |word|
      word.length > 4
    end
      #=> true


**#include?**
 -include does not take a code block, but it is an enumerable
  and it will return true if the argument can be found in 
  the list. it is case sensitive

    [1, 2, 3].include?(1)
      => true
     
    [1, 2, 3].include?(4)
      => false

**documentation** 
 -chech this page out if you ever want: 

  http://ruby-doc.org/core-2.2.2/Enumerable.html


//////////////////////////////////////////////////////////////
        UNDERSTANDING YIELD AND BLOCKS 
**what are blocks**
 -as we saw with enumerables, they all need to take a block
  of code
 -blocks of code are defined by curly braces{} or being 
  inside the "do" and "end" keywords
 
**enumerables and blocks**
 -the enumerable methods all manage to "yeild" a value from
  a collection into a block, they do that under the hood
  with the "yield" keyword
 -you can also create enumerable functions that yeild values
 -the yeild keyword basically pauses your method, evaluates
  a block of code, and then comes back into your method
 -to pass values into a block, pass them as arguments
  with yeild: 


    def foo
      i = 1
      j = 2
      yield(i, j)
    end 
    # then when you call foo, provide a block

    foo {|i,j| puts "#{i} #{j}"}

    # here is an example with no values passed into the block
    # and returns back to the original method: 

    def yielding
      puts "the program is executing the code inside the method"
      yield
      puts "now we are back in the method"
    end

    yielding {puts "the method has yielded to the block!"}
    # > the program is executing the code inside the method
        the method has yielded to the block!
        now we are back in the method

    # see how we hop over to the yeild section, then 
    # back to the method? 

**making an enumerable method with yeild and an array**
  -we can work with an array and yield as well
 -below is a function that will work through an array
  and do whatever we want with each index value 

    def hello_t(array)
      i = 0
     
      while i < array.length
        yield array[i]
        i = i + 1
      end

      return array
    end

 -before we get to the block of code, lets look at how this 
  works
 -the loop starts and will only go for as long as the array is
 -so then we pass over the value of the first index 
 -then it gets evaluated and does whatever the code block does
 -but THEN we return to the method, i is increased by one,
  and then it starts all over again and only stops once the
  list runs out 
 -this is how we iterate 
 -you can also see we are in control of the return value now,
  more on that later

 -now that we know how the method works, the block is simple:

    hello_t(names) {|name| puts name.capitalize}

 -so we assign "name" to the passed value of the array and
  then capitalize it and print it 

**returning values from yield and the block**
 -getting a return value from the block is simple, just 
  assign yield to a variable
 -to get a map like return, where we return a new array of 
  all our values, it's simple: 

    def hello_t(array)
      i = 0
      new_arr = []
      while i < array.length
        new_val = yield(array[i])
        new_arr << new_val
        i = i + 1
      end

      return new_arr
    end
 
 -we create a new empty array, then assign our yeild to a var
 -now the code block will automatically get a return value
  of the last executed statement 
 -which then gets assigned to our variable 
 -then just push that variable into our new_arr
 -then, instead of returning the original array, return the
  new one 
 -it should be noted you could also return anythign else, like
  just a single value or a boolean: 

  # here we are returning the first value we find,
  # where the block evaluates to true
  # it will exit out of the method with a return statement
  # but if we go through the whole array and find no true,
  # the method itself returns a value of false 
 
     def hello_t(array)
      i = 0
      while i < array.length
        new_val = yield(array[i])
        if new_val == true
          return array[i]
        end 
        i = i + 1
      end
      return false
    end
 
**dealing with missing blocks**
 -ruby has the method #block_given? which can tell if a block
  has been provided or not 
 -to elegantly handle an ommision of a block, use a simple 
  conditional check
 -if you don't, and no block is given, you will get a yield
  LocalJumpError in your code: 

    def hello_t(array)
      if block_given?
        i = 0
     
        while i < array.length
          yield(array[i])
          i = i + 1
        end
     
        array
      else
        puts "Hey! No block was given!"
      end
    end 

 -you can also have the method do something more interesting
  that output a warning, you could have it carry out an 
  entirely different function


