
////////////////////////////////////////////////
        JS/JQUERY BOOK: CH 1

review:

OBJECT ORIENTED: objects are MODELED with data
    and each time one appears it is called an 
    INSTANCE.

PROPERTIES: characteristcs of an object, each
    property has a variable and a value.

EVENT: When a user interacts with a program and 
    triggers a reaction

METHODS: functions that are defined in an object


*Web browsers are object oriented*
    -the browser represents each window and tab 
     using a WINDOW OBJECT 
        -The location property has the URL as 
         the value
    -The current web page loaded in the 
     browser is modeled using the 
     DOCUMENT OBJECT


*The Document Object represents an HTML page*
    -Using the Document Object you can access
     and change what the user sees on the page.
    -It has properties, events, and methods from
     the HTML code
    -The Document Object is just one of a set of
     objects all browsers support. 
    -When a browser creates the document object
     of a webpage, it also creates a new object
     for every element on the page
    -together, all thes objects create the 
     DOCUMENT OBJECT MODEL (ch. 5 for more)


*How a browser sees a page*
1. recieve page html code
    -these are the individual HTML documents
2. create the DOM (document object model) of 
   the page and store it in memory:

    DOCUMENT   top is the DOCUMENT OBJECT, each
       |       item below is both a node and an
    <HTML>     object.
       |-----------------------|
    <HEAD>                  <BODY>
       |--------|              |---------|
    <TITLE>  <LINK>           <h1>      <p>
       |        |              |         |
     name      css            text     text 

3. Use a rendering engine to display the page
    -if no css is linked to it, it will display
     presets




                   LEARN COURSE 
============================================================
                  The basics
============================================================
**opening the JS console in Chrome, safari, firefox**
 -use cmd + shift + c for chrome 
 -cmd + alt + K in firefox
 -cmd + alt + C in safari 
 -like a real console, typing the up and down arrows will
  move you through the console's history

**the console is a playground**
 -in this console you can type JS and the page will respond
 
**alert() method**
 -this accepts a string and prints it to the screen in 
  an alert box pop up 

**double quotes, single quotes, and escaping**
 -" and ' have no functional difference since interpolation
  is done using template strings with ``, so just use one or
  the other to avoid errors: 

    "this isn't an issues"
    'this isn't going to work'
    'unless you\'re escaping the quote'

 -that forward slash tells JS to "escape" the following 
  character, that is to treat it as a simple text character
  and nothing more so it will print


============================================================
                  comments
============================================================
**comment your damn code**
 -seriously do it 

**single vs multiline** 
 // this is a single line 

 /*
  this is a 
  multi 
  line
 */

 // This is 
 // also 
 // quite 
 // common


============================================================
                  data types 
============================================================
**weak typing**
 -JS is a weak type of language, it will try to coerce 
  your data types to match, if they are different, which
  leads to intersting situations 

    2 + "2" = "22" 
 
 -here is realized that you can't "add" a number and a string
  but you can turn the int into a string and then 
  concatenate, which is what it did and always will do
 -JS "coerced" the int's data type from number into string 

**typeof method** 
 -the typeof() method takes a data type as an argument 
  and returns a string of the objects data type 
**data types of JS** 
 -here they are: 

  typeof(1)  // "number"   / notice both ints and 
  typeof(.2) // "number"   / floats are the same type 
  typeof("2)" // "string"
  typeof([1]) // "array"
  typeof({"hey": "there}) // "object" 
  typeof(true) // "boolean"  / notice they aren't capitalized
  typeof(undefined) // "undefined"
  typeof(null) // "null"
  typeof(function(){}) // "function"

**strings concatenation and interpolation**
 -concatenation is simple 

    let str = "hello " + "there." 
    // "hello there 

 -interpolation is done by using "template strings" 
  which are denoted by `` backticks and ${}
 
    let name = "nate"
    console.log(`Hello ${name}`)
    // Hello nate
    console.log(`${2 + 2}`)
    // 4 

 -this is a new feature with ES2015, so a lot of older code
  uses concat 
    
  

============================================================
                  JS Logging 
============================================================
**you can send data to the console**
 -this is helpful to show you what your code is doing while
  it runs and checking breakpoints 
 -this is done with the console object 

**console**
 -cmd + K is used to clear away your console 
 -you can also click the slashed circle in the corner of 
  the console windowz
 -we know the console is an object because of typeof, 
  which returns "object" when you enter console, and if you 
  just type "console" into the console, it returns an object
 
**log()**
 -when calling methods on an object, use dot notation 
  
    console.log("I'm logged")
    let foo = "so am I!"
    console.log(name)
    console.log('one', 'two', 'three')    
    // comma separated values are printed with spaces between
 
 -you can console log almost anything, and it can take mltiple
  arguments of different types (strings, variables, numbers
  etc) 

**error()**
 -console.error() will print out a custom message and a "stack
  trace" of code that was evaluated before the error went 
 -this info is available by clicking on the arrow next to 
  the error message in the console 
  -clicking on the lines will take you to that section in your
   code 
 
    console.error("I can", "take multiple", "args")

 -if it's testing, use log, but if you actualy are checking 
  errors, use .error()
 -NOTE: error() does not actualy throw an error, your code 
  will continue to move 

**warn()**
 -this is good for telling developers what they MIGHT not 
  want to do as the warning message is not an error



=============================================================
     JavaScript Variable Assignment and Declaration  
=============================================================
**dynamically typed language**
 -js needs a keyword to tell it that a word is a variable,  
  but it can be assigned any type without specifying and that
  type can be reassigned at any time (except for constants)

**proper names**
 -JS tends to use camelCaseForVariables (this is helpful
  since HTML favors name-dashes so it's easy to distinguish)
 -can't start with a number, but can be an _
 -dashes can't be used 
 -are case sensitive  

**multiline assignments** 

  let name = "jeff";
  let name2 = "sarah";
  // works ok
  let name = "jeff",
    name2 = "sarah";
 
 -with multiline assignments, variables of the same type 
  (var, let or const) can be separated by commas with a ; 
  only at the end of the very last assignment
 -values do not have to be assigned, you can just declare: 

  let name, age, number;

 -lint (a type of forced style guide) requires that each 
  scope have its variables listed in this manner

**reassining** 

    let myNote = "Get milk"
 
    // later on
     
    myNote = "Get cookies"

 -that's really all there is to it

**scope**
 -scope in JS referes to where in code a variable can be used
 -js variables can be accessed from the scope they are 
  declared in, and one scope below that. They can't be 
  accessed from a scope one level above where they have been
  declared though
 -so a variable declared in the main scope, can be accessed 
  from inside a function in the main scope, but the main scope
  can't access variables declared in the function scope 

  let name = "jane";
   
  function thing() {
    console.log(name); // this is fine 
    let bar = "foo";
  }

  console.log(thing); // this produces an error

//////////////////////////////////////////////////////////////
 -there are now 3 different keywords to use to declare vars, 
  and they each have a different meaning: 

                 var VS let VS const 

**var and hoisting**
 -when you declare variables with var, they get 
  hoisted to the top of its scope: 
 -this means that their declarations all come up at the top 
  of a script, so they can be invoked without calling issues

  // so this: 

  function foo(bool) {
    if (bool) {
      var bar = "hello there";
      console.log(bar);
      // this logs "hello there"
    } else {
      console.log(bar);
      // this logs undefined, not give an error, even though
      // it wasn't even declared right? 
      console.log(asdadferg);
      // like this would give us an error since that variable 
      // was never defined 
    }
  }

  // the reason that bar is just undefined is becuase hoisting 
  // hoists all var declarations to the top of the scope before
  // running the script, so behind the scenes we get: 

  function foo(bool) {
    var bar;
    if (bool) {
      bar = "hello there"
      ...
 
 -apparently this hoisting mechanic is super weird and throws 
  a lot of developers off, so new declaration keywords that 
  go by code block, not scope, were created

**let**
 -the let keyword prevents hoisting and only allows the variable
  to be used within it's block: 

  function foo(bool) {
      if (bool) {
        let bar = "hello there";
        console.log(bar);
        // this logs "hello there"
      } else {
        console.log(bar);
        // now this throws an error, since bar is in another 
        // code block and is not hoisted 
      }
    }

**const** 
 -the const keyword also restricts variables to their block,
  BUT it also restricts reassignment of the variable within
  each scope: 

  let tomato = "fruit";
  tomato = "veggie";
  // this is fine
  var potato = "potayto";
  potato = "potahto";
  // obvi fine all along
  const ham = "cheese";
  ham = "turkey";
  // this throws an error 

 -note that const blocks re assignment, but that does not mean 
  the variable is immutable: 

  const arr = ["a", "b", "c"];
  arr.push("d");
  // this works fine 
  arr = ["x", "y", "z"];
  // this throws an error

**which do you use?**
 -honestly the jury is still out
 - most agree to avoid var unless you NEED it for some reason
 -then some say default to const unless you need the variable
  to change, then use let
 -others say default to let, then change to const if it 
  turns out the variable doesn't need to change
 -the second school makes slightly more sense since making a 
  variable a const incorrectly throws an error, but a let 
  that never happens to need to change is just fine

**global variables** 
 -if you don't use any variable keyword, the variable will 
  have global scope 

    ham = "food";

 -this means it can be acessed from anywhere in your code 
 -however it takes up a lot of memory and is bad practice 
 -also, local variables override it, but aren't the same  
  thing, which is confusing and terrible 

    //declares a global variable called volume, sets it to 10
    volume = 10; 
 
    function returnEleven() {
      //declares a local variable called volume, sets it to 11
      var volume = 11;  
      return volume;
    }
     
    returnEleven(); // returns 11
    volume; // the global variable is still 10
     
    function goToEleven(){
      volume = 11;  //changes the global variable to 11
      return volume;
    }
     
    goToEleven(); // returns 11
    // the global variable volume has been changed to 11
    volume; 

 -even worse, a global can also overwrite a local: 

    function sayHello() {
      var greeting = "hola";
      greeting = "hello";
      return greeting;
    }
     
    sayHello()
    // Returns "hello",
    // This demonstrates that the variable greeting is now 
    // pointing to the string "hello" instead of "hola"
     
    greeting
    // ReferenceError: greeting is not defined
    // This demonstrates that the variable greeting is 
    // still local instead of global

 -globals are bad and should be avoided, in fact lint will see
  them as an error and won't run your code 
      
=============================================================
              intro to functions 
=============================================================
**what is a function**
 -a function is a group of repeatable instructions that you
  "call" by writing its name with () and passing args, 
  if any are needed: 

  function sayHello(name) {
    console.log(`Hello ${name}`);
  }
  
  sayHello("mark");
  // Hello mark

**parameters and arguments** 
 -in the function definition, the values passed into it are 
  called parameters, but when the function is called and the
  actual values are passed into it, those values are called 
  arguments.
 -parametes are planning, arguments are action 
 -order matters with arguments, the order entered determines
  what values go where

  function say(greeting, firstName) {
    console.log(`${greeting}, ${firstName}!`)
  }
  say("Julio", "hello")
  // Julio, hello

**default values** 
 -thanks to new ES2015 standards, JS now accepts default 
  arguments: 

    function sayHello(name="Karen") {
      console.log(`Hello! ${name}`);
    }

    sayHello()
    // Hello! Karen

 -however, default arguments must go at the end, because 
  variables will still be assigned in order: 

  function sayHello(name, name2="Karen") {
    console.log(`Hello! ${name} ${name2}`);
  } 
  sayHello("mark")
  // Hello! mark undefined 

 -it's not like ruby, it can't figure it out if you put the 
  default variable first 

**function overloading/no arguments** 
 -if you don't provide enough arguments, JS assigns those 
  arguments a value of undefined (this can be used to check
  how many arguments have been given, but that's advanced) 
 -however, if you give too many arguments, JS just takes 
  the proper amount it needs, and all the extras left over at 
  the end are simply ignored 

    alert("printed", "ignored", "without issue") 
    // alert only takes one argument, so it uses the first 

 **what are () for?**
 -if you call a function without () at the end, it is not 
  called, it is just referenced.
 -if you type a function into the console, it will simply
  print out the function definition 
 -some things appear to be functions, like .length, since 
  they seem to return a value on the object, however they
  don't take parenthesis because they are actually properties
  -more on this much later
 -bottom line is, don't forget the () on your functions if
  you want to call them, even if no args are passed in 
  
**getting values OUT of functions**
 -so use arguments to pass info in, but use the return 
  keyword to get values out of a function
 -the return keyword is NEVER implicit like ruby

  function say(greeting, firstName) {
    return `${greeting}, ${firstName}!`
  }

  let greeting = say("hello", "sarah") 
  greeting now equals "hello sarah" 

 -you can return anything out of a function, objects and 
  arrays are no problem
 -arrays are how you return more than one piece: 

  function multiplyVals(val1,val2) { 
    return [val1 * 2, val2 * 4]
  }
  
  multiplyVals(3,9)
  // [6, 36]




==============================================================
                  Flow control and conditionals 
==============================================================
**flow control**
 -if something is this, then do that 
 -so if the statment in the () is evaluated to be true, 
  then the code block attached to it is executed, 
 -the program then leaves the whole check and continues on
  with the program
 

**basic syntax**

    if (val > 4) {
      go()
    } else if (val == 3) {
      stop()
    } else if (val < 3) {
      slowDown()
    } else {
      blowUp()
    }

 -notice that "else if" is two words and how each conditional
  check goes in ( ) and each statement to be evaluated goes 
  in a block of { }
 -if statements can go on their own without the else or 
  else if parts 
 -the code that is found to be true FIRST is executed, and 
  ONLY that code is executed, so keep this in mind for 
  orderin your statements, you want the least broad checks
  first 

**operators** 
  <=, ==, >=  = less than or equal, equal, greater or equal 
  !=   = not equal 
  <==, ===, >==, !== 
   -adding that extra "=" does not allow for type coercion,
    if the compared objects are not the same data type, it
    will always be false 

    5 == "5"  // true 
    5 === "5" // false 
    
**logical comparisons**
 -you can combine two statements with && and || to evaluate
  both as a single phrase and return a single true or false  
  
  4 > 5 || 6 < 10 
  // the "or" operator returns true if one or more conditon
  // is true 
  // so this is true 

  5 == 5 && 10 > 1
  // "and" means both must be true to return a true value 

//////////////////////////////////////////////////////////////
**ternary operator**
 -handy shortcut for a simple if else statement: 

  condition ? valueIfTrue : valueIfFalse
 
  ...code 
  return 4 < 10 && 0 == "0" ? "neat" : "what? false?"
  ... more code 

//////////////////////////////////////////////////////////////
**truthy and falsey** 
 look at this 

  if ("sarah") {
    //code 
  }

 -how does that evaluate? 
 -in JS there are "truthy" values and "falsey" values
 -these values will be coerced into logical true or falses 
  to get through comparison checks 
 -all values are truthy except for: 

    false, 0, "" (empty string), null, undefined, and NaN
    
 -everything else is true, the only odd one is an empty array
  and object, unlike an empty string, count as truthy  

**NOT true and False though**
 -truthy does not actually mean true, so a direct comparison
  will not work

    (true == "ham") // false 

 -think of truthy and falsey values to be what JS turns to
  when there are no purely logical true and false options 

**weird comparisons**
 -the infamous 

    (0 == []) //true
    ("0" == 0) //true 
    ("0" == []) //false 

 is a result of coercion and truthy values
 -an empty array in a logical check is coerces into an 
  empty string, which is falsy, and a 0 is also falsey, so 
  two falsey values are equal, so the statment is true
 -however, a string of "0" is not the same as "", so they are
  now not equal, and thus false 
 -the weirdness comes from the fact that on it's own [] is 
  true: 

    if ([]) {
     //this will execute since it is true
    }
 
 -but when compared to other things, it becomes "", which is 
  falsey 
//////////////////////////////////////////////////////////////
**short circuiting**
 -if the first value in an "or" comparison is true, JS won't
  bother evaluationg the second stament, since there's no
  way to change the phrase's value 
 -an "and" comparison with a first value of false will ignore
  the second statment for the same reason: the phrase has to
  be false 
 -logical operators when used to assign a variable, will
  assign it the value that is true: 

    thing = true || false 
    // thing is set to true 

    thing = "" || "greg"
    // since "" is falsey, it is assigned a value of greg 

 -use this behavior with || to assign values to a variable 
  ONLY if they haven't already been assigned

    let name = name || "greg"
    // since  name has not been assigned any value yet, 
    // it has an "undefined" value, which is falsey, so the 
    // "or" check returns the only truthy value of "greg" 
    
    let name = "sarah"
    name = name || "greg"
    // now, name = sarah, so the || "short circuits", it sees
    // a true value, meaning the whole phrase must be true,
    // so it doesn't bother evaluating the second value 
    // (which happens to be true), so now the only value on
    // that side of = is "sarah", the value of name 

//////////////////////////////////////////////////////////////
**switch statements** 
 -here's the basic structure: 

var mood = "hungry"
switch(mood) { 
  case "happy":
    console.log("Dance to Pharrell's 'Happy'");
    break;
  case "sad":
    console.log("You should eat a pint of ice cream");
    break;
  case "anxious":
    console.log("Take some deep breaths");
    break;
  case "hungry":
    console.log("You should eat a big chocolate cake");
    break;
  default:
    console.log("That's not a mood we support");
}
 
 -the whole thing is wrapped in brackets and indendetd
 -so the mood value is simply checked agains the single 
  value ater the case keyword
 -if it is found to match, the following code is executed 
 -NOTE: switch statemnts cannot use any logical or comarison
  operators, it must jsut simply match 
 -the default value is triggered if no exact matches are found
  like the else keyword, the default section is optional 

**hacking a switch statments** 
 -notice all those breaks? without those, the code will just 
  keep looking for the next true statement 
 -so if one of the options you wanted to be evaluated, but 
  then also the default as well, then on that case block,
  leave out the break keyword 
 -this is also a hacky way to get ranges: 

function switchAge(age) {
  switch (age) {
  case 13:
  case 14:
  case 15:
  case 16:
  case 17:
  case 18:
  case 19:
    return "You are a teenager"
    break; 
  default:  
    return "You have an age"
      // code to be executed if case n and case m false
  }
}

 -this is saying if the value of age is 13 to 19, it will 
  return you are a teenager 


//////////////////////////////////////////////////////////////
**a quick word on return vs break** 
 -break (and later on you'll see continue) is a keyword that 
  tells JS to leave that code block (like an if..else block 
  or a switch statement) and keep running the next part of
  code 
 -however, if you have say, an if...else check in a function
  and one of the options has a "return" keyword inside 

  function thing(val){
    if (val) {
      return "hello there"
    } else {
      //more code
    }
    console.log("ehllo")
  }
 
 -if that val is evaluated to true, the WHOLE function is 
  exited with a return value of "hello there", the console
  log will never be reached. However, if you hit the else,  
  JS's built in "break" behind the scenes would simply exit
  out of the check and back into the function

==============================================================
                  JS Arithmetic/Assignment operators 
==============================================================
**basic arithmetic symbols** 
 -they are all here: 
  +,-,*,/ = what you think
  %  = modulo, which returns the remainder 
  // the ** is new to ES2015
  ** = to power 5 ** 2 == five to the power of 2 

**increments and decrement** 
 -js includes the shorthand ++/-- operators: 
  
  i++ == i = i + 1
  i-- == i = i - 1

 -if the --/++ is placed after, the number is first 
  evaluated, then incremented, if the --/++ go before, then
  the number is changed THEN evaluated 
 -to see this clearly, go to a console and try these

  let number = 5
  console.log(number++) // 5 
  number = 5
  console.log(number--) // 5 
  number = 5
  console.log(++number) // 6
  number = 5
  console.log(--number) // 4 

 -this only really matters when returning a value, if you
  --/++, by the end of a line, all subsequent lines will
  have the same value to work with (like counting in loops)

    var i = 0;
    ++i;
    console.log(i == 1); // true

    var i = 0;
    i++;
    console.log(i == 1); // true

 -it's also rare to see them in front anyway

**assignment operators**
 -in addition to =, there are 
  +=,-=,/=,*=,%= 
  // and in es2015
  **= 
 -what those do is 

    i = i + 5 == i += 5
    i = i - 5 == i -= 5
    i = i * 5 == i *= 5
    i = i / 5 == i /= 5
    i = i % 5 == i %= 5
    
 -since they are more explicit, +=/-= are prefered over --/++
  (except for loops, no one uses i += 1, they do i++)

//////////////////////////////////////////////////////////////
**turning strings into numbers**
 -since js is loosely typed, it will coerce a number and a 
  string into a string and a string 
  
    2 + "2" = "22" 

 -when working with user input, this is no good, since all 
  user input is a string
 -we need to convert strings to numbers 

**Number()**
 -the easiest way to do this is with Number() 

    let num = "2"
    let realNum = Number(num)
    // realNum == 2 
    num = "2.2"
    realNum = Number(num)
    // real num is the float 2.2 
    num = "1cm"
    realNum = Number(num)
    // realNum is NaN
 
 -basically, if a string is just an int or float, it will 
  convert it into an int or float 
 -if there are any non number characters in the string though,
  it will return a value of NaN

**NaN and isNaN()** 
 -NaN the value returned when you try to do an arithmetic 
  operation on a non number 
 -you can easily check if a value is a number or not with the
  isNaN() method: 

    let num = "4";
    console.log(isNaN(num)); // false 

 -isNaN() returns true if the argument it takes is NOT NaN, 
  and true if it is NaN
 -it doesn't care about null, undefined, or bool, it if is 
  not NaN, it will return false, there is no type coercion
 -it only takes one argument

    




























 
 



























////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
                JS Selecting elements 
**query selector is easiest**

    document.querySelector()
    document.querySelectorAll()

 -this is the simplest way to select any item 
  you want, it can take classes, ids, tag names
 -if you want a nodelist/colleciton, use the all counterpart
 
  document.querySelector('#content')
  document.getElementById('content')
  // when using querySelectors you MUST include the # and .

  document.querySelectorAll('.red')
  document.getElementsByClassName('red')

  document.querySelectorAll('p')
  document.getElementsByTagName('p')

 -above are the "traditional" ways compared to the newer 
  (though not new) query selector method
 -NOTE: if you use regular querySelector() on a node list,
  it will just return the first element as a single value,
  not a list of one item.

**selecting ancestry** 
 -you can chain the selectors together in order to move 
  down the dom to get a specific element
 -this is called chaining in JS, and some functions can do it

  document.querySelector(".infobox").querySelector("span.deathplace").querySelector("a")

 -so first it selects the first instance of the class infobox
  then out of the children of that element, it selects the
  first span tag with a class of "deathplace" then it 
  finally selects the first a tag in that 

**retrieving attributes and .constructor** 
 -once you have an element selected, you can store it in a 
  variable: 

    let maryleboneAnchor = document.querySelector(".infobox").querySelector("span.deathplace").querySelector("a")
maryleboneAnchor.constructor
 // ƒ HTMLAnchorElement() { [native code] }

 -so that variable actually stores the commented out value 
  and it is the output of the consturctor property, which
  shows it is a descendent of the AnchorElement()







////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////
        JS SPEED OPTIMIZATION

1. Reduce activity in loops 

    ie. Don't make js evaluate stuff in a loop 
    it doesn't have to: 

BAD:
    for (var i = 0; i < arr.length; i++) {
    //it re evalues arr.length everytime, 
    //even though it doesn't change

GOOD
    var i;
    var l = arr.length;
    for (i = 0; i < l; i++) {
    //now it evaluates once then uses the value
    //for each loop

2. Reduce DOM access

    Accessing the DOM takes time, if you are 
    going to do it more than once, assign
    it to a variable: 

    var obj;
    obj = document.getElementById("demo");
    obj.innerHTML = "Hello";


3. Smaller DOMs

    Just make the page as small as it needs 
    to be, eliminate bloat. 


4. Avoid Unnecessary variables 

    Only create variables that save new values,
    if one variable is just a combination of 
    other variables, try to add them only where
    they need to be:

BAD

    var fullName = firstName + " " + lastName;
    document.getElementById("demo").innerHTML 
        = fullName;
    // do you really need that fullName vari?

GOOD
    
    document.getElementById("demo").innerHTML 
        = firstName + " " + lastName
    //same effect, much faster 


5. Put your script at the end of the page 

    This means the elements of the page that 
    the user can see always load before the
    js does. You can also wrap your code in 
    an onLoad() function to ensure that no
    matter where it is placed, it loads last

6. Don't use the with keyword

    It's just bad for speed and isn't even
    allowed in strict mode



       


////////////////////////////////////////////////
            USEFUL FUNCTIONS 

 
------------------------------------------------
.indexOf() 

  Find the first index of a value in an array.
  It will return the number of the index of a
  given value, or a -1 if the value is not in
  the array.

SYNTAX
array.indexOf(item, start) 

    item 
        -REQ. This is the value you are 
         searching for. 
  start
    -OPT. Tells the program on what index to 
     start looking. The index is inclusive.
     Negative values will search from that
     position from the end (-2 is 2nd from
     the last index)

USES 
    .indexOf() is used for what you think, but
    by including a start argument, you can find
    a duplicate values next index:
    
    arr.indexOf(value, 1st-values-index)
    //this tells it to find the next instance
    //of that value 

   
------------------------------------------------
.lastIndexOf()

  Find the last index of a value in an array.

SYNTAX
array.indexOf(item, start) 

    The only difference is that the search 
    goes right to left, instead of left to
    right. 
    The start argument will start there and 
    go to the beginning 

USES 
    
    For what you'd think, operates the same
    as indexOf, just in a mirrored direction.


------------------------------------------------
Number()

    Convert a non-number object to a numberical
    value. If no number can be returned, it will
    produce Nan. If no object is provided, it 
    will return 0.

SYNTAX
Number(object)

USES 
    Look at the values that will be returned when
    they are plugged into Number():

    var x1 = true;
    var x2 = false;
    var x3 = new Date();
    var x4 = "999";
    var x5 = "999 888";

    Number(x1) // 1 
    Number(x2) // 0 
    Number(x3) // mS since jan 1st 1970
    Number(x4) // 999
    Number(x5) // NaN



------------------------------------------------
.toString()

    Convert a number to a string. It can also
    convert a number into a string of binary,
    octal, or hexidecimal value 

SYNTAX
number.toString(radix)

    radix - OPTIONAL. Which base to use for 
    representing a numeric value. Must be an 
    integer between 2 and 36.

    2 - The number will show as a binary value
    8 - The number will show as an octal value
    16 - The number will show as an hexadecimal 
         value



------------------------------------------------
.split()

    Split a string object into an array of 
    substrings using a specified separator. 
    If the string is empty, it will return an
    empty array.

SYNTAX

str.split(separator, limit)

    separator -REQ. This string is the mark
        separates out the array. 
    limit -OPT. This int. decides how many 
        values in the new array there will
        be. 

USES
    Split a word into letters by doing

    word.split('')
    // ["c", "a", "t", "s"]

    split a sentance into words:
    sent.split(' ')
    //["hi,", "how", "are", "you?"]
    //notice punctuation is included

    remove spaces:
    var names = 'Harry Trump ;Fred Barney; 
    Helen Rigby ; Bill Abel ;Chris Hand ';
    var re = /\s*;\s*/;
    var nameList = names.split(re);
    // that removes any spaces befor or 
    // after the semi colon character
    // the formula for spaces is \s*
    // and then surround them with /  /



------------------------------------------------
.reverse()

    Reverse the order of the elements in an 
    array 


SYNTAX 
arr.reverse()
    
    It takes no arguments. It just reverses an
    array 

    ["one", "two", "three"]  is the start
    ["three", "two", "one"]  is what you'd get



------------------------------------------------
.join()
    
    Combine an array into a string. The new 
    string will have each value separated by
    a comma unless specified otherwise. If an
    emptry array is joined, it will creat an
    empty string.

SYNTAX
arr.join(separator)

    separator - OPT. This character(s) will be
        what goes inbetween the values in the 
        new string. use "" an empty string if
        you don't want anything between the 
        values (ie, joining a word)


USES
    most commonly used to reverse a string:

    str.split('').reverse().join('')
    //splits it, reverses the array, then
    //joins it back together in a chain

    
    can format lists into nice strings 

    var a = ['Wind', 'Rain', 'Fire'];
    a.join();      // 'Wind,Rain,Fire'
    a.join('');    // 'WindRainFire'
    a.join(', ');  // 'Wind, Rain, Fire'
    a.join(' + '); // 'Wind + Rain + Fire'



------------------------------------------------
Math.ceil() and Math.floor()

    The Math.ceil() function returns the 
    smallest integer greater than or equal to a 
    given number. Basically, it rounds up every 
    time unless the the number is x.0, then
    it returns the given number x.

    Math.ceil() always rounds up
    
    Math.ceil(.95);    // 1
    Math.ceil(4);      // 4
    Math.ceil(7.004);  // 8
    Math.ceil(-0.95);  // -0
    Math.ceil(-4);     // -4
    Math.ceil(-7.004); // -7

    
    The Math.floor() function returns the 
    largest integer less than or equal to a given 
    number.
    Math.floor() always rounds down:

    Math.floor( 45.95); //  45
    Math.floor( 45.05); //  45
    Math.floor(  4   ); //   4
    Math.floor(-45.05); // -46 
    Math.floor(-45.95); // -46

    NOTE: don't just use ceil() or .floor(), 
    you have to use Math.ceil() or Math.floor()


------------------------------------------------
MORE QUICK MATH FUNCTIONS

Math.round(4.7);    // returns 5
Math.round(4.4);    // returns 4

Math.pow(8, 2);      // returns 64 (x, y) is x^y

Math.sqrt(64);      // returns square root of 8

Math.abs(-4.7);     // returns absolute value 4.7

Math.min(0, 150, 30, 20, -8, -200);  // returns -200

arr = [0, 150, 30, 20, -8, -200];
Math.max(...arr)
Math.min(...arr)
Math.max.apply(null, arr)
Math.min.apply(null, arr) 
-if you want to apply min or max to a list you
  need to either use ... operator which is the
  spread operator, OR use Function.protoype.apply()
which allows you to apply a this value to your 
array

------------------------------------------------
LOOPING THROUGH OBJECT 
var obj = {a: 1, b: 2, c: 3};
    
for (var prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
}

// Output:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"

it's syntax: 
for (var variable in object) {

}

for (var k in target){
  if (typeof target[k] !== 'function') {
     alert("Key is " + k + ", value is" + target[k]);
    }
}
-getting key/value pairs works how you'd think.
-To check if target has a property:

for (var k in target){
  if (target.hasOwnProperty(k)) { 
    alert("Key is " + k + ", value is" + target[k]);
    }
}
-that checks if k property (like "name") is in an
object;
------------------------------------------------
LOOPING THROUGH LIST WITH FOR EACH

var a = ['a', 'b', 'c'];

a.forEach(function(element) {
    console.log(element);
});

// a
// b
// c

-It's basically a pythnon for loop

------------------------------------------------
QUICK AND DIRTY REFERENCE FUNCTIONS/COMMON STUFF



document.body = the body of the document 
document.getElementById("id-name")
-returns one element 

document.querySelector(".class:last-child")
-returns the FIRST element that matches the
  css style selector, that one above is just
  an example

document.getElementsByClassName("class-name"),
document.getElementsByTagName('div"),
document.querySelectorAll(".class > id-name"),
-these all return node lists, which are 
  array-like objects, so to get them into a 
  classic array use 

  Array.prototype.slice().call(nodeListName) 

arr.valueOf(index)
-gets value at index

arr.push(value)
-adds a value to an array at the last index

arr.unshift(value) 
-adds a value to an array at the first index

arr.pop()
-removes last item in a list, but saves it as a
  return value if you want to store it

arr.splice(index, howmany, item1,...itemX)
-index of item to be removed from list, howmany
  is an integer that specifies what needs to be
  added or removed
-if 0 is howmany, nothing is removed and you 
  can specify what items to add at that index
-or remove some, then put some in, or just remove
-negative values go from the end of an array 
  (-2 is second from the last, example)

arr.slice(start, end)
-create a new list that is a slice of an old one
  if only the start index is given, it will 
  assume you want the slice to go to the end of 
  the array. if no indexes are given, it's just a
  full copy
-negative values go from the end of an array 
  (-2 is second from the last, example)

arr.length = 0 
-This is the only way to clear a lits since: 
  arr = {}
  creates a duplicate version of the list that is
  blank

element.focus()
-gives focus to an input

input.value 
-gets the value of an input NO () 

document.createElement('tag')
-creates an empty element
document.createTextNode("text"//variable)
-creates just a text node
element.appendChild(elementChild)
-appends an element to another 
element.innerHTML("<p>html stuff")
-get or set the value of html
element.textContent("stuff")
-get or set the elements text content 

Math.floor((Math.random() * 10) + 1);
-generates a random number between 1 and 10
-you need the floor to keep from rounding errors)

element.id = the id or set it
element.className = get/set classname
element.className += " otherClass"
-that last one is how you add a class name 
  instead of setting it's total string 

var d = new Date()
new Date()
new Date(milliseconds)
new Date(dateString) //the default value actually
new Date(year, month, day, hours, minutes, seconds, milliseconds)
//use those parameters to set the date if you need
to

var d = new Date().getDay()
//returns number 1-31
~,getFullYear //gets year
~.getHours() //gets 0-23 for hour
~.getMonth() //gets 0-11

-remember, if no timezone is specified, the 
  browser returns the time/date for its own
  specific timezone

element.style.camelCaseProperty = "value"
newDiv.style.backgroundColor = "red"
-this is how you style css 

element.setAttribute(name, value)
newDive.setAttribute("id", "car")
-set a tag's attribute 

element.getAttribute(name)
-gets a tag's attribute

element.removeAttribute(name);
-Removes an entire attribute object from 
  element

var elmnt = document.getElementById("myAnchor");   // Get the <a> element with id="myAnchor"
var attr = elmnt.getAttributeNode("href");         // Get the href attribute node from <a>
elmnt.removeAttributeNode(attr);
-this removes an attribute node 


------------------------------------------------
SWITCH STATEMENT SYNTAX: 

switch(expression) {
    case n:
        code block
        break;
    case n:
        code block
        break;
    default:
        code block
}
switch(favCar) {
    case "BMW":
      text = "German car";
      break;
    case "Ford":
      text = "American car";
      break;
    case "Peugeot":
      text = "French car";
      break;
    default:
      text = "Unknown car name";
  }
-the default needs no break; statement
-in fact, you can ditch the default if you 
don't want a catchall
-you can't use < or > logical or ranges, the 
case must only have a single possibility per
case
------------------------------------------------
------------------------------------------------
array vs Node list vs HTML collection 

an array is an array, you know what it does.
node lists and html collections are array like,
meaning they can't use a lot of the functions
by default. they do use [0] and .length off the
bad though

HTML Collections can be accessed by name, id, or
index number, Node Lists can only be accessed by
index number.

convert it into an array if you want to use any
array functions:
valueOf(), push(), pop(), indexOf(), join()


















////////////////////////////////////////////////
      SELECTING THE CHILDREN OF AN ELEMENT

  document.(element).nowSelectsFromChildren

    SO:
  document.getElementById("k").getElementsByTag
    Name("img")[0]

  Now, that getElementsByTagName will only 
  return those tags that are the children of 
  the element whose id is "k".
  -the chain would continue with each . 

  doc.(element).(child).(grandchild)


////////////////////////////////////////////////
