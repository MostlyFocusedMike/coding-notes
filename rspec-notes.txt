RSPEC NOTES
==============================================================
                  intro 
==============================================================
 -RSpec is a unit test framework for the Ruby programming 
  language. 
 -RSpec is a Behavior driven development tool. 
 -this means rspec focuses on what gets done, not how
 -RSpec is a DSL, a Domain Specific Language, which means
  its built atop Ruby to add extra functionality

**RSpec Environment**
 -rspec is a ruby gem so install with:

    $ gem install rspec
 
 -in linux you ,ight need sudo


**Hello World**
 -To get started, let’s create a directory (folder) to store 
  our RSpec files. 
 -make a folder for your project, then in that folder make a 
  "spec" folder
 -We are going to store our RSpec files in this folder. 
 -RSpec files are known as “specs”, whigh stands for 
  specifications

 -Since, RSpec is a BDD test tool, the goal is to focus on 
  what the application does and whether or not it follows 
 -this is becayse rspec is testing whether program meets a
  behavioral specification, oft described as a"user story"
 -inside practice/spec make a file hello_spec.rb and put:

    class HelloWorld

       def say_hello 
          "Hello World!"
       end
       
    end

    describe HelloWorld do 
       context “When testing the HelloWorld class” do 
          
          it "says 'Hello World' when we call the method" do 
             hw = HelloWorld.new 
             message = hw.say_hello 
             expect(message).to eq "Hello World!"
          end
          
       end
    end

 -then back in terminal:
 
    $ rspec spec spec\hello_world_spec.rb

 -which should put this:

    Finished in 0.002 sec (files took0101 seconds to load) 
    1 example, 0 failures


==============================================================
                Basic syntax
==============================================================
 -Here is the RSpec code again −

    describe HelloWorld do 
       context “When testing the HelloWorld class” do 
          
          it "it should return 'Hello World'" do 
             hw = HelloWorld.new 
             message = hw.say_hello 
             expect(message).to eq "Hello World!" 
          end
          
       end 
    end

 -that is the main test section, the hello world function
  is whats getting tested
 -code being tested would normally be its own file
  as we see later how to do

**The describe Keyword**
 -The word "describe" is an RSpec keyword. It is used to 
  define an “Example Group”. 
 -an “Example Group” as a collection of tests. 
 -The describe keyword can take a class name and/or string
  argument. 
 -You also need to pass a block argument to describe,
  this will contain the individual tests, or as they are 
  known in RSpec, the “Examples”. 
 -The block is just a Ruby block designated by the 
  Ruby do/end keywords.

**The context Keyword**
 -The context keyword is similar to describe. 
 -It too can accept a class name and/or string argument. 
  and the code goes in a block
 -The idea of context is that it encloses tests of a 
  certain type.

 -For example: 

context “passing bad parameters to the foobar() method” 
context “passing valid parameters to the foobar() method” 
context “testing corner cases with the foobar() method”

 -The context keyword is not mandatory, but it helps to 
  add more details about the examples that it contains.

**The it Keyword**
 -The word it is another RSpec keyword which is used to 
  define an “Example”. 
 -to only pass a string and block argument. 
 -The string argument often uses the word “should” and
  describes what should happen inside the it block. 
 -the block contains the actual code that will test your
  program 

**The expect Keyword**
 -The expect keyword is used to define an “Expectation” 
  in RSpec. 
 -This is a verification step where we check
  that a specific expected condition has been met.

    expect(message).to eq "Hello World!"
 
 -as you can see RSpec tries to be read aloud easily


**The to keyword**
 -The to keyword is used as part of expect statements. 
 -Note that you can also use the not_to keyword 
  to express the opposite 
 -You can see that to is used with a dot, 
   
    expect(message).to, because it actually just a 

  because it is just a regular Ruby method #to
 -In fact, all of the RSpec keywords are really just Ruby 
  methods.

**The eq keyword**
 -The eq keyword is a special RSpec keyword called a Matcher.
 -You use Matchers to specify what type of condition you are 
  testing to be true (or false).
 -so in our example clearly we are testing to see if the 
  putput matches the string
 -there are different types of equality operators in Ruby 
  and consequently different Matchers in RSpec. 


/
/
/
/
/
/
/
/
/
/
/

==============================================================
                Writing Specs
==============================================================
**testing a separate file**
 -here's the code example in a different file, it returns true
  if there are any vowels in the string

    class StringAnalyzer 
       def has_vowels?(str) 
          !!(str =~ /[aeio]+/i) 
       end 
    end

 -save this in a file string_analyzer.rb in the spec folder
 -Here is the source for our spec file to test StringAnalyzer:

  require 'string_analyzer' 

  describe StringAnalyzer do 
     context "With valid input" do 
        
        it "should detect when a string contains vowels" do 
           sa = StringAnalyzer.new 
           test_string = 'uuu' 
           expect(sa.has_vowels? test_string).to be true 
        end 
      
        it "should know if a string doesn't contain vowels" do 
           sa = StringAnalyzer.new 
           test_string = 'bcdfg' 
           expect(sa.has_vowels? test_string).to be false
        end 
        
     end 
  end
 -Save this in the same spec directory, giving it the name 
  string_analyzer_spec.rb.
 -all spec files must end in _spec.rb, this is how rspec knows
  to run and test with those files 
 -cd out of the spec folder, then do: 

    $ rspec spec 

 -it will run all the tests and show you the failures 
 -(In this example you will fail because in the code your list
  of vowels does not include "u", add that, save, then run 
  tests again to pass) 

**good test questions**
 -so if you're looking for vowels, here are some good tests
  to run to really get all the use cases:
Input string	Description	Expected resultdd with has_vowels?
  (input strings)
  (description)
  (return value)

  ‘aaa’, ‘eee’, ‘iii’, ‘o’
  Only one vowel and no other letters.	
  true

  ‘abcefg’	
  ‘At least one vowel and some consonants’	
  true

  ‘mnklp’	
  Only consonants.	
  false

  ‘’	
  Empty string (no letters)	
  false

  ‘abcde55345&??’	
  Vowels, consonants, numbers and punctuation characters.	
  true

‘423432%%%^&’	Numbers and punctuation characters only.	false
‘AEIOU’	Upper case vowels only.	true
‘AeiOuuuA’	Upper case and lower vowels only.	true
‘AbCdEfghI’	Upper and lower case vowels and consonants.	true
‘BCDFG’	Upper case consonants only.	false
‘ ‘	Whitespace characters only.	false
It is up to you to decide, which examples to add to your spec file. There are many conditions to test for, you need to determine what subset of conditions is most important and tests your code the best.

The rspec command offers many different options, to see them all, type rspec -help. The following table lists the most popular options and describes what they do.

Option/flag & Description
-f, --format FORMATTER
  This option allows you to specify different output formats. 
  See the section on Formatters for more details about output 
  formats.
 here are the two main ones:
-fd  // d stands for documentation
  this is the formatting option that learn.co seems to use,
  it displays all tests, with passed ones in green, and failed
  ones in red, but both types fully display describe and 
  context 
 here are the two main ones:
-fp // p stands for progress
  this is the default behavior of RSpec, it will just put
  green dot for each passed test and a "F" for failed tests.
  the only place to see the details of failed tests is below
  the F and dots in the "Failures:" section.
  -this is the default behavior so you don't need to specify
-I PATH
  Adds PATH to the load (require) path that rspec uses when 
  looking for Ruby source files.

-r, --require PATH
  Adds a specific source file to be required in your spec. 
  file(s).

--fail-fast
  With this option, rspec will stop running specs after the 
  first Example fails. By default, rspec runs all specified 
  spec files, no matter how many failures there are.


-o, --out FILE

  This option directs rspec to write the test results to the 
  output file FILE instead of to standard out.

-c, --color
  Enables color in rspec’s output. Successful Example results 
  will display in green text, failures will print in red text.

-b, --backtrace
  Displays full error backtraces in rspec’s output.

-w, --warnings
  Displays Ruby warnings in rspec’s output.

-P, --pattern PATTERN
  Load and run spec files that match the pattern PATTERN. For 
  example, if you pass -p “*.rb”, rspec will run all Ruby 
  files, not just the ones that end in “_spec.rb”.

-e, --example STRING
  This option directs rspec to run all Examples that contain 
  the text STRING in their descriptions.

-t, --tag TAG
  With this option, rspec will only run examples that contain 
  the tag TAG. Note that TAG is specified as a Ruby symbol. 
  See the section on RSpec Tags for more details.



/
/
/
/
/
/
/ 
MATCHERS 

eq	
Passes when actual == expected	
expect(actual).to eq expected

eql	
Passes when actual.eql?(expected)	
expect(actual).to eql expected

be	
Passes when actual.equal?(expected)
expect(actual).to be expected


