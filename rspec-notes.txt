RSPEC NOTES
==============================================================
                  intro 
==============================================================
 -RSpec is a unit test framework for the Ruby programming 
  language. 
 -RSpec is a Behavior driven development tool. 
 -this means rspec focuses on what gets done, not how
 -RSpec is a DSL, a Domain Specific Language, which means
  its built atop Ruby to add extra functionality

**RSpec Environment**
 -rspec is a ruby gem so install with:

    $ gem install rspec
 
 -in linux you ,ight need sudo


**Hello World**
 -To get started, let’s create a directory (folder) to store 
  our RSpec files. 
 -make a folder for your project, then in that folder make a 
  "spec" folder
 -We are going to store our RSpec files in this folder. 
 -RSpec files are known as “specs”, whigh stands for 
  specifications

 -Since, RSpec is a BDD test tool, the goal is to focus on 
  what the application does and whether or not it follows 
 -this is becayse rspec is testing whether program meets a
  behavioral specification, oft described as a"user story"
 -inside practice/spec make a file hello_spec.rb and put:

    class HelloWorld

       def say_hello 
          "Hello World!"
       end
       
    end

    describe HelloWorld do 
       context “When testing the HelloWorld class” do 
          
          it "says 'Hello World' when we call the method" do 
             hw = HelloWorld.new 
             message = hw.say_hello 
             expect(message).to eq "Hello World!"
          end
          
       end
    end

 -then back in terminal:
 
    $ rspec spec spec\hello_world_spec.rb

 -which should put this:

    Finished in 0.002 sec (files took0101 seconds to load) 
    1 example, 0 failures


==============================================================
                Basic syntax
==============================================================
 -Here is the RSpec code again −

    describe HelloWorld do 
       context “When testing the HelloWorld class” do 
          
          it "it should return 'Hello World'" do 
             hw = HelloWorld.new 
             message = hw.say_hello 
             expect(message).to eq "Hello World!" 
          end
          
       end 
    end

 -that is the main test section, the hello world function
  is whats getting tested
 -code being tested would normally be its own file
  as we see later how to do

**The describe Keyword**
 -The word "describe" is an RSpec keyword. It is used to 
  define an “Example Group”. 
 -an “Example Group” as a collection of tests. 
 -The describe keyword can take a class name and/or string
  argument. 
 -You also need to pass a block argument to describe,
  this will contain the individual tests, or as they are 
  known in RSpec, the “Examples”. 
 -The block is just a Ruby block designated by the 
  Ruby do/end keywords.

**The context Keyword**
 -The context keyword is similar to describe. 
 -It too can accept a class name and/or string argument. 
  and the code goes in a block
 -The idea of context is that it encloses tests of a 
  certain type.

 -For example: 

context “passing bad parameters to the foobar() method” 
context “passing valid parameters to the foobar() method” 
context “testing corner cases with the foobar() method”

 -The context keyword is not mandatory, but it helps to 
  add more details about the examples that it contains.

**The it Keyword**
 -The word it is another RSpec keyword which is used to 
  define an “Example”. 
 -to only pass a string and block argument. 
 -The string argument often uses the word “should” and
  describes what should happen inside the it block. 
 -the block contains the actual code that will test your
  program 

**The expect Keyword**
 -The expect keyword is used to define an “Expectation” 
  in RSpec. 
 -This is a verification step where we check
  that a specific expected condition has been met.

    expect(message).to eq "Hello World!"
 
 -as you can see RSpec tries to be read aloud easily


**The to keyword**
 -The to keyword is used as part of expect statements. 
 -Note that you can also use the not_to keyword 
  to express the opposite 
 -You can see that to is used with a dot, 
   
    expect(message).to, because it actually just a 

  because it is just a regular Ruby method #to
 -In fact, all of the RSpec keywords are really just Ruby 
  methods.

**The eq keyword**
 -The eq keyword is a special RSpec keyword called a Matcher.
 -You use Matchers to specify what type of condition you are 
  testing to be true (or false).
 -so in our example clearly we are testing to see if the 
  putput matches the string
 -there are different types of equality operators in Ruby 
  and consequently different Matchers in RSpec. 


/
/
/
/
/
/
/
/
/
/
/

==============================================================
                Writing Specs
==============================================================
**testing a separate file**
 -here's the code example in a different file, it returns true
  if there are any vowels in the string

    class StringAnalyzer 
       def has_vowels?(str) 
          !!(str =~ /[aeio]+/i) 
       end 
    end

 -save this in a file string_analyzer.rb in the spec folder
 -Here is the source for our spec file to test StringAnalyzer:

  require 'string_analyzer' 

  describe StringAnalyzer do 
     context "With valid input" do 
        
        it "should detect when a string contains vowels" do 
           sa = StringAnalyzer.new 
           test_string = 'uuu' 
           expect(sa.has_vowels? test_string).to be true 
        end 
      
        it "should know if a string doesn't contain vowels" do 
           sa = StringAnalyzer.new 
           test_string = 'bcdfg' 
           expect(sa.has_vowels? test_string).to be false
        end 
        
     end 
  end
 -Save this in the same spec directory, giving it the name 
  string_analyzer_spec.rb.
 -all spec files must end in _spec.rb, this is how rspec knows
  to run and test with those files 
 -cd out of the spec folder, then do: 

    $ rspec spec 

 -it will run all the tests and show you the failures 
 -(In this example you will fail because in the code your list
  of vowels does not include "u", add that, save, then run 
  tests again to pass) 

**good test questions**
 -so if you're looking for vowels, here are some good tests
  to run to really get all the use cases:
Input string	Description	Expected resultdd with has_vowels?
  (input strings)
  (description)
  (return value)

  ‘aaa’, ‘eee’, ‘iii’, ‘o’
  Only one vowel and no other letters.	
  true

  ‘abcefg’	
  ‘At least one vowel and some consonants’	
  true

  ‘mnklp’	
  Only consonants.	
  false

  ‘’	
  Empty string (no letters)	
  false

  ‘abcde55345&??’	
  Vowels, consonants, numbers and punctuation characters.	
  true

‘423432%%%^&’	Numbers and punctuation characters only.	false
‘AEIOU’	Upper case vowels only.	true
‘AeiOuuuA’	Upper case and lower vowels only.	true
‘AbCdEfghI’	Upper and lower case vowels and consonants.	true
‘BCDFG’	Upper case consonants only.	false
‘ ‘	Whitespace characters only.	false

//////////////////////////////////////////////////////////////
**options/flags for rspec**
 -The rspec command offers many different options, to see them 
  all, type rspec -help. 
 -The following table lists the most popular options and 
  describes what they do.

Option/flag & Description
-f, --format FORMATTER
  This option allows you to specify different output formats. 
  See the section on Formatters for more details about output 
  formats.
 here are the two main ones:

-fd  // d stands for documentation
  this is the formatting option that learn.co seems to use,
  it displays all tests, with passed ones in green, and failed
  ones in red, but both types fully display describe and 
  context 
 here are the two main ones:

-fp // p stands for progress
  this is the default behavior of RSpec, it will just put
  green dot for each passed test and a "F" for failed tests.
  the only place to see the details of failed tests is below
  the F and dots in the "Failures:" section.
  -this is the default behavior so you don't need to specify

-I PATH
  Adds PATH to the load (require) path that rspec uses when 
  looking for Ruby source files.

-r, --require PATH
  Adds a specific source file to be required in your spec. 
  file(s).

--fail-fast
  With this option, rspec will stop running specs after the 
  first Example fails. By default, rspec runs all specified 
  spec files, no matter how many failures there are.


-o, --out FILE

  This option directs rspec to write the test results to the 
  output file FILE instead of to standard out.

-c, --color
  Enables color in rspec’s output. Successful Example results 
  will display in green text, failures will print in red text.
  seems to be default

-b, --backtrace
  Displays full error backtraces in rspec’s output.

-w, --warnings
  Displays Ruby warnings in rspec’s output.

-P, --pattern PATTERN
  Load and run spec files that match the pattern PATTERN. For 
  example, if you pass -p “*.rb”, rspec will run all Ruby 
  files, not just the ones that end in “_spec.rb”.

-e, --example STRING
  This option directs rspec to run all Examples that contain 
  the text STRING in their descriptions.

-t, --tag TAG
  With this option, rspec will only run examples that contain 
  the tag TAG. Note that TAG is specified as a Ruby symbol. 
  See the section on RSpec Tags for more details.



/
/
/
/
/
/
/ 
MATCHERS 
 -here are some of the matchers (the part that tests whether
  or not the value from .expect is equal)

  eq	
  Passes when actual == expected	
  ex: expect(actual).to eq expected

  eql	
  Passes when actual.eql?(expected)	
  ex: expect(actual).to eql expected

  be	
  Passes when actual.equal?(expected)
  ex: expect(actual).to be expected

  equal 
  also passes when actual.equal?(expected)
  ex: expect(actual).to equal expected

 -here they are in context: 

  describe "An example of the equality Matchers" do 
    it "should show how the equality Matchers work" do 
      a = "test string" 
      b = a 
        
      # The following Expectations will all pass 
      expect(a).to eq "test string" 
      expect(a).to eql "test string" 
      expect(a).to be b 
      expect(a).to equal b 
    end
  end

 -this will pass

**comparison matchers**
 -you can also use the regular comparisons: 

  >	
  Passes when actual > expected	
  expect(actual).to be > expected

  >=, <, <=	
  -these work just like above 
 
  be_between(x,y).inclusive 
  Passes when actual is <= min and >= max
  expect(actual).to be_between(min, max).inclusive

  be_between exclusive
  Passes when actual is < min and > max
  expect(actual).to be_between(min, max).exclusive

  match
  Passes when actual matches a regular expression
  expect(actual).to match(/regex/)

-again here they are incontext, notice you need to use the 
  "be" matcher:

describe "An example of the comparison Matchers" do
   it "should show how the comparison Matchers work" do
      a = 1
      b = 2
      c = 3		
      d = 'test string'
      # The following Expectations will all pass
      expect(b).to be > a
      expect(a).to be >= a 
      expect(a).to be < b 
      expect(b).to be <= b 
      expect(c).to be_between(1,3).inclusive 
      expect(b).to be_between(1,3).exclusive 
      expect(d).to match /TEST/i 
   end
end

**class/Type matechers**
 -here is how you test for type and class: 

    be_instance_of	
    Passes when actual is an instance of the expected class.	
    expect(actual).to be_instance_of(Expected)

    be_kind_of	
    Passes when actual is an instance of the expected class or 
      any of its parent classes.	
    expect(actual).to be_kind_of(Expected)

    respond_to	
    Passes when actual responds to the specified method.	
    expect(actual).to respond_to(expected)

 -context: 

describe "An example of the type/class Matchers" do
 
   it "should show how the type/class Matchers work" do
      x = 1 
      y = 3.14 
      z = 'test string' 
      
      # The following Expectations will all pass
      expect(x).to be_instance_of Fixnum 
      expect(y).to be_kind_of Numeric 
      expect(z).to respond_to(:length) 
   end
   
end

**true false and nill matchers**

    be true	
    Passes when actual == true	
    expect(actual).to be true

    be false	
    Passes when actual == false	
    expect(actual).to be false

    be_truthy	
    Passes when actual is not false or nil	
    expect(actual).to be_truthy

    be_falsey	
    Passes when actual is false or nil	
    expect(actual).to be_falsey

    be_nil	
    Passes when actual is nil	
    expect(actual).to be_nil

 context: 

  describe "An example of the true/false/nil Matchers" do
   it "should show how the true/false/nil Matchers work" do
      x = true 
      y = false 
      z = nil 
      a = "test string" 
      
      # The following Expectations will all pass
      expect(x).to be true 
      expect(y).to be false 
      expect(a).to be_truthy 
      expect(z).to be_falsey 
      expect(z).to be_nil 
     end 
  end

**error matchers**

  raise_error(ErrorClass)	
  Passes when the block raises an error of type ErrorClass.	
  expect {block}.to raise_error(ErrorClass)

  raise_error("error message")	
  Passes when the block raise an error with the message 
    “error message”.	
  expect {block}.to raise_error(“error message”)

  raise_error(ErrorClass, "error message")	
  Passes when the block raises an error of type ErrorClass 
    with the message “error message”	
  expect {block}.to raise_error(ErrorClass,“error message”)

 
==============================================================
            test doubles (mocks)
==============================================================
**a test double is essentially a dummy class** 
 -lets say we have a ClassRoom class, that accecpts student
  objects, and one of the ClassRoom class functions takes each
  student objects :name and joins it into a string: 

  class ClassRoom 
   def initialize(students) 
      @students = students 
   end
   
   def list_student_names 
      @students.map(&:name).join(',') 
   end 
end

 -so if you only have that class, and not the Student class,
  how would you test it? 
 -by using the rspec #double method

describe ClassRoom do 
   it 'the list_student_names method should work correctly' do 
      student1 = double('student') 
      student2 = double('student') 
      
      allow(student1).to receive(:name) { 'John S'} 
      allow(student2).to receive(:name) { 'Jill S'} 
      
      cr = ClassRoom.new [student1,student2]
      expect(cr.list_student_names).to eq('John S,Jill S') 
   end 
end

 -what #double does in that code is assign each student as an
  instance of the Student class (note you spell it lowecase)
  which essentially does this: 

    class Student
    end 

    student1 = Student.new

 -and then use this syntax to add methods and properties to
  your "class" 
  
    allow(student1).to receive(:name) { 'John S'}
    allow(var).to receive(:property) {definition}

 -once our students each have a name property, we create a 
  real instance of classroom, passing in the student objects
  in an array: 

    cr = ClassRoom.new [student1,student2]

 -finally, test it using the usual expect and eq: 

    expect(cr.list_student_names).to eq('John S,Jill S') 

 -use test doubles to tell there is a problem with a specific
  class that you are testing (ClassRoom) and not another

    
==============================================================
            Stubbing
==============================================================
**stubbing basics**
 -stubbing (or method stub) as it is called, is a special type
  of method that stands in for an existing method, or method
  that doesn't exist yet
 -for example, when you fake what user input SHOULD be and 
  then act on that in the test 
 
**stubbing with puts/print**
 -how do you test puts and print< they have no return value
 -you test it by checking Ruby's special global $stdout
 
 #old way
 # RSpec code 
  it "should test puts " do 
    expect($stdout).to receive(:puts).with("on terminal")
    puts "on terminal" # or your method that uses puts
  end

 -first we tell rspec to expect that puts will be used to
  pass "on the termnial" to $stdout 
 -then we use puts (or rhe method that outputs) afterwards
  to actually output text
 -there are many ways to accomplish this, but this pattern
  is fastest


  # new way as of 2014 and rspec 3.0
  it "should test puts " do 
    expect{ puts_method}.to output("hello there\n").to_stdout
    expect{ print_method}.to output("hello there").to_stdout
  end

 -the muvh cleaner output().to_stdout method just takes 
  the expects method and the method to test, then the text
  that you want inside output
 -also note that with prints and puts you need to account
  for the newline character


**testing gets**
 -you essentially tell self to expect the gets method, 
  and return "text" when its called
 -you then run the method that calls gets
 -once ruby comes to the gets call, it will put in the 
  value specified before
 
  it "should call gets once" do
    expect(self).to receive(:gets).and_return("s")
    thing = gets.strip
    expect(thing).to eq("s")
  end

  it "should call gets twice" do
    expect(self).to receive(:gets).and_return("one")
    expect(self).to receive(:gets).and_return("two")
    thing = gets.strip
    thing2 = gets.strip
    expect([thing, thing2]).to eq(["one","two"])
  end

 -notice that the gets values are filled in from their
  original order
 -the first gets value gets put in the first gets call
 -not like it calls the most recent value first
 -first returned, first called

**gets and puts together**
 -play song gets a user's song choice, and then puts it to 
  the screen
 -here is how you would test something like that

  it "can use a full song name to find a song" do
    allow(self).to receive(:gets).and_return("Phoenix - 1901")
    expect{ play(songs) }.to output(/Phoenix - 1901/).to_stdout
  end

 -we are telling "self" to recieve
  a fake "gets" call, and then artificially return an input
  of "Phoenix..." 
 -now, when we call the play method, when it gets to the 
  gets.chomp line, it will look back and see "Phoe.." is the
  output, which allows the test to continue 

